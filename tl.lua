local a;if(tonumber((_VERSION or''):match('[%d.]*$'))or 0)<5.3 then local b,c=pcall(require,'compat53.module')if b then a=c end end;local assert=a and a.assert or assert;local debug=a and a.debug or debug;local io=a and a.io or io;local ipairs=a and a.ipairs or ipairs;local load=a and a.load or load;local math=a and a.math or math;local d=math.maxinteger or math.pow(2,53)local os=a and a.os or os;local package=a and a.package or package;local pairs=a and a.pairs or pairs;local string=a and a.string or string;local table=a and a.table or table;local type=type;local utf8=a and a.utf8 or utf8;local e="0.24.4+dev"local f=[=====[
do global type any global type thread global type userdata local enum FileStringMode "a" "l" "L" "*a" "*l" "*L" end local enum FileNumberMode "n" "*n" end local enum FileMode "a" "l" "L" "*a" "*l" "*L" "n" "*n" end global record FILE userdata enum SeekWhence "set" "cur" "end" end enum SetVBufMode "no" "full" "line" end close:function(FILE):boolean,string,integer flush:function(FILE) lines:function(FILE):(function():(string)) lines:function(FILE,FileNumberMode...):(function():(number...)) lines:function(FILE,(number|FileStringMode)...):(function():(string...)) lines:function(FILE,(number|FileMode)...):(function():((string|number)...)) lines:function(FILE,(number|string)...):(function():(string...)) read:function(FILE):string read:function(FILE,FileNumberMode...):number...read:function(FILE,(number|FileStringMode)...):string...read:function(FILE,(number|FileMode)...):((string|number)...) read:function(FILE,(number|string)...):(string...) seek:function(FILE,?SeekWhence,?integer):integer,string setvbuf:function(FILE,SetVBufMode,?integer) write:function(FILE,(string|number)...):FILE,string metamethod __close:function(FILE) end global record coroutine type Function=function(any...):any...close:function(thread):boolean,string create:function(Function):thread isyieldable:function():boolean resume:function(thread,any...):boolean,any...running:function():thread,boolean status:function(thread):string wrap:function<F>(F):F yield:function(any...):any...end global record debug record GetInfoTable name:string namewhat:string source:string short_src:string linedefined:integer lastlinedefined:integer what:string currentline:integer istailcall:boolean nups:integer nparams:integer isvararg:boolean func:any activelines:{integer:boolean} end enum HookEvent "call" "tail call" "return" "line" "count" end type HookFunction=function(HookEvent,integer) type AnyFunction=function(any...):any...debug:function() gethook:function(?thread):HookFunction,integer getinfo:function(AnyFunction|integer):GetInfoTable getinfo:function(AnyFunction|integer,string):GetInfoTable getinfo:function(thread,AnyFunction|integer,string):GetInfoTable getlocal:function(thread,AnyFunction,integer):string getlocal:function(thread,integer,integer):string,any getlocal:function(AnyFunction,integer):string getlocal:function(integer,integer):string,any getmetatable:function<T>(T):metatable<T> getregistry:function():{any:any} getupvalue:function(AnyFunction,integer):any getuservalue:function(userdata,integer):any sethook:function(thread,HookFunction,string,?integer) sethook:function(HookFunction,string,?integer) setlocal:function(thread,integer,integer,any):string setlocal:function(integer,integer,any):string setmetatable:function<T>(T,metatable<T>):T setupvalue:function(AnyFunction,integer,any):string setuservalue:function<U>(U,any,integer):U traceback:function(thread,?string,?integer):string traceback:function(?string,?integer):string upvalueid:function(AnyFunction,integer):userdata upvaluejoin:function(AnyFunction,integer,AnyFunction,integer) end global record io enum OpenMode "r" "w" "a" "r+" "w+" "a+" "rb" "wb" "ab" "r+b" "w+b" "a+b" "*r" "*w" "*a" "*r+" "*w+" "*a+" "*rb" "*wb" "*ab" "*r+b" "*w+b" "*a+b" end close:function(?FILE) input:function(?FILE|string):FILE flush:function() lines:function(?string):(function():(string)) lines:function(?string,FileNumberMode...):(function():(number...)) lines:function(?string,(number|FileStringMode)...):(function():(string...)) lines:function(?string,(number|FileMode)...):(function():((string|number)...)) lines:function(?string,(number|string)...):(function():(string...)) open:function(string,?OpenMode):FILE,string,integer output:function(?FILE|string):FILE popen:function(string,?OpenMode):FILE,string read:function():string read:function(FileNumberMode...):number...read:function((number|FileStringMode)...):string...read:function((number|FileMode)...):((string|number)...) read:function((number|string)...):(string...) stderr:FILE stdin:FILE stdout:FILE tmpfile:function():FILE type:function(any):string write:function((string|number)...):FILE,string end global record math type Numeric=number|integer abs:function<N is Numeric>(N):N acos:function(number):number asin:function(number):number atan:function(number,?number):number atan2:function(number,number):number ceil:function(number):integer cos:function(number):number cosh:function(number):number deg:function(number):number exp:function(number):number floor:function(number):integer fmod:function(integer,integer):integer fmod:function(number,number):number frexp:function(number):number,integer huge:number ldexp:function(number,integer):number log:function(number,?number):number log10:function(number):number max:function(integer...):integer max:function((number|integer)...):number max:function<T>(T...):T max:function(any...):any maxinteger:integer min:function(integer...):integer min:function((number|integer)...):number min:function<T>(T...):T min:function(any...):any mininteger:integer modf:function(number):integer,number pi:number pow:function(number,number):number rad:function(number):number random:function(integer,?integer):integer random:function():number randomseed:function(?integer,?integer):integer,integer sin:function(number):number sinh:function(number):number sqrt:function(number):number tan:function(number):number tanh:function(number):number tointeger:function(any):integer type:function(any):string ult:function(number,number):boolean end global record metatable<T> enum Mode "k" "v" "kv" end __call:function(T,any...):any...__mode:Mode __name:string __tostring:function(T):string __pairs:function<K,V>(T):function():(K,V) __index:any __newindex:any __gc:function(T) __close:function(T) __add:function<A,B,C>(A,B):C __sub:function<A,B,C>(A,B):C __mul:function<A,B,C>(A,B):C __div:function<A,B,C>(A,B):C __idiv:function<A,B,C>(A,B):C __mod:function<A,B,C>(A,B):C __pow:function<A,B,C>(A,B):C __band:function<A,B,C>(A,B):C __bor:function<A,B,C>(A,B):C __bxor:function<A,B,C>(A,B):C __shl:function<A,B,C>(A,B):C __shr:function<A,B,C>(A,B):C __concat:function<A,B,C>(A,B):C __len:function<A>(T):A __unm:function<A>(T):A __bnot:function<A>(T):A __eq:function<A,B>(A,B):boolean __lt:function<A,B>(A,B):boolean __le:function<A,B>(A,B):boolean end global record os record DateTable year:integer month:integer day:integer hour:integer min:integer sec:integer wday:integer yday:integer isdst:boolean end enum DateMode "!*t" "*t" end clock:function():number date:function(DateMode,?number):DateTable date:function(?string,?number):string difftime:function(integer,integer):number execute:function(string):boolean,string,integer exit:function(?(integer|boolean),?boolean) getenv:function(string):string remove:function(string):boolean,string rename:function(string,string):boolean,string setlocale:function(string,?string):string time:function(?DateTable):integer tmpname:function():string end global record package config:string cpath:string loaded:{string:any} loadlib:function(string,string):(function) loaders:{ function(string):any,any } path:string preload:{any:any} searchers:{ function(string):any } searchpath:function(string,string,?string,?string):string,string end global record string byte:function(string,?integer):integer byte:function(string,integer,?integer):integer...char:function(integer...):string dump:function(function(any...):(any),?boolean):string find:function(string,string,?integer,?boolean):integer,integer,string...format:function(string,any...):string gmatch:function(string,string,?integer):(function():string...) gsub:function(string,string,string,?integer):string,integer gsub:function(string,string,{string:string},?integer):string,integer gsub:function(string,string,function(string...):((string|integer|number)...),?integer):string,integer len:function(string):integer lower:function(string):string match:function(string,string,?integer):string...pack:function(string,any...):string packsize:function(string):integer rep:function(string,integer,?string):string reverse:function(string):string sub:function(string,integer,?integer):string unpack:function(string,string,?integer):any...upper:function(string):string end global record table type SortFunction=function<A>(A,A):boolean record PackTable<A> is {A} n:integer end concat:function({(string|number)},?string,?integer,?integer):string insert:function<A>({A},integer,A) insert:function<A>({A},A) move:function<A>({A},integer,integer,integer,?{A}):{A} pack:function<T>(T...):PackTable<T> pack:function(any...):{any:any} remove:function<A>({A},?integer):A sort:function<A>({A},?SortFunction<A>) unpack:function<A>({A},?number,?number):A... unpack:function<A1,A2>({A1,A2}):A1,A2 unpack:function<A1,A2,A3>({A1,A2,A3}):A1,A2,A3 unpack:function<A1,A2,A3,A4>({A1,A2,A3,A4}):A1,A2,A3,A4 unpack:function<A1,A2,A3,A4,A5>({A1,A2,A3,A4,A5}):A1,A2,A3,A4,A5 end global record utf8 char:function(number...):string charpattern:string codepoint:function(string,?number,?number,?boolean):number...codes:function(string,?boolean):(function(string,?number):(number,number)) len:function(string,?number,?number,?boolean):number offset:function(string,number,?number):number end local record StandardLibrary enum CollectGarbageCommand "collect" "count" "stop" "restart" end enum CollectGarbageSetValue "step" "setpause" "setstepmul" end enum CollectGarbageIsRunning "isrunning" end type LoadFunction=function():string enum LoadMode "b" "t" "bt" end type XpcallMsghFunction=function(...:any):() arg:{string} assert:function<A,B>(A,?B,...:any):A collectgarbage:function(?CollectGarbageCommand):number collectgarbage:function(CollectGarbageSetValue,integer):number collectgarbage:function(CollectGarbageIsRunning):boolean collectgarbage:function(string,?number):(boolean|number) dofile:function(?string):any...error:function(?any,?integer) getmetatable:function<T>(T):metatable<T> ipairs:function<A>({A}):(function():(integer,A)) load:function((string|LoadFunction),?string,?LoadMode,?table):(function,string) load:function((string|LoadFunction),?string,?string,?table):(function,string) loadfile:function(?string,?string,?{any:any}):(function,string) next:function<K,V>({K:V},?K):(K,V) next:function<A>({A},?integer):(integer,A) pairs:function<K,V>({K:V}):(function():(K,V)) pcall:function(function(any...):(any...),any...):boolean,any...print:function(any...) rawequal:function(any,any):boolean rawget:function<K,V>({K:V},K):V rawget:function({any:any},any):any rawget:function(any,any):any rawlen:function<A>({A}):integer rawset:function<K,V>({K:V},K,V):{K:V} rawset:function({any:any},any,any):{any:any} rawset:function(any,any,any):any require:function(string):any select:function<T>(integer,T...):T...select:function(integer,any...):any...select:function(string,any...):integer setmetatable:function<T>(T,metatable<T>):T tonumber:function(any):number tonumber:function(any,integer):integer tostring:function(any):string type:function(any):string warn:function(string,string...) xpcall:function(function(any...):(any...),XpcallMsghFunction,any...):boolean,any..._VERSION:string end global arg <const> =StandardLibrary.arg global assert <const> =StandardLibrary.assert global collectgarbage <const> =StandardLibrary.collectgarbage global dofile <const> =StandardLibrary.dofile global error <const> =StandardLibrary.error global getmetatable <const> =StandardLibrary.getmetatable global load <const> =StandardLibrary.load global loadfile <const> =StandardLibrary.loadfile global next <const> =StandardLibrary.next global pairs <const> =StandardLibrary.pairs global pcall <const> =StandardLibrary.pcall global print <const> =StandardLibrary.print global rawequal <const> =StandardLibrary.rawequal global rawget <const> =StandardLibrary.rawget global rawlen <const> =StandardLibrary.rawlen global rawset <const> =StandardLibrary.rawset global require <const> =StandardLibrary.require global select <const> =StandardLibrary.select global setmetatable <const> =StandardLibrary.setmetatable global tostring <const> =StandardLibrary.tostring global tonumber <const> =StandardLibrary.tonumber global ipairs <const> =StandardLibrary.ipairs global type <const> =StandardLibrary.type global xpcall <const> =StandardLibrary.xpcall global _VERSION <const> =StandardLibrary._VERSION end
]=====]local g={}local h={GenerateOptions={},CheckOptions={},Env={},Result={},Error={},TypeInfo={},TypeReport={},EnvOptions={},Token={},TypeCheckOptions={}}local i={}local j={["unknown"]=true,["unused"]=true,["redeclaration"]=true,["branch"]=true,["hint"]=true,["debug"]=true,["unread"]=true}h.warning_kinds=j;h.typecodes={NIL=0x00000001,NUMBER=0x00000002,BOOLEAN=0x00000004,STRING=0x00000008,TABLE=0x00000010,FUNCTION=0x00000020,USERDATA=0x00000040,THREAD=0x00000080,INTEGER=0x00010002,ENUM=0x00010004,EMPTY_TABLE=0x00000008,ARRAY=0x00010008,RECORD=0x00020008,MAP=0x00040008,TUPLE=0x00080008,INTERFACE=0x00100008,SELF=0x00200008,POLY=0x20000020,UNION=0x40000000,NOMINAL=0x10000000,TYPE_VARIABLE=0x08000000,ANY=0xffffffff,UNKNOWN=0x80008000,INVALID=0x80000000}local k="optional"local l="5.3"local m=os.getenv("TL_DEBUG")local n=os.getenv("TL_DEBUG_FACTS")local o=d;if n and not m then m="1"end;if m then local p=assert(tonumber(m),"TL_DEBUG was defined, but not a number")if p<0 then o=math.tointeger(-p)elseif p>1 then local q=0;local r;debug.sethook(function(s)if s=="call"or s=="tail call"or s=="return"then local t=debug.getinfo(2)if r then if t.name==r and s=="return"then r=nil end;return elseif(t.name or"?"):match("^tl_debug_")and s=="call"then r=t.name;return end;local u=t.name or"<anon>",t.currentline>0 and"@"..t.currentline or""io.stderr:write(u," :: ",s,"\n")io.stderr:flush()else q=q+100;if q>p then error("Too many instructions")end end end,"cr",100)end end;do local v={["start"]=nil,["any"]=nil,["identifier"]="identifier",["got -"]="op",["got --"]=nil,["got ."]=".",["got .."]="op",["got ="]="op",["got ~"]="op",["got ["]="[",["got 0"]="number",["got <"]="op",["got >"]="op",["got /"]="op",["got :"]="op",["got --["]=nil,["string single"]="$ERR$",["string single got \\"]="$ERR$",["string double"]="$ERR$",["string double got \\"]="$ERR$",["string long"]="$ERR$",["string long got ]"]="$ERR$",["comment short"]=nil,["comment long"]="$ERR$",["comment long got ]"]="$ERR$",["number dec"]="integer",["number decfloat"]="number",["number hex"]="integer",["number hexfloat"]="number",["number power"]="number",["number powersign"]="$ERR$",["pragma"]=nil,["pragma any"]=nil,["pragma word"]="pragma_identifier"}local w={["and"]=true,["break"]=true,["do"]=true,["else"]=true,["elseif"]=true,["end"]=true,["false"]=true,["for"]=true,["function"]=true,["goto"]=true,["if"]=true,["in"]=true,["local"]=true,["nil"]=true,["not"]=true,["or"]=true,["repeat"]=true,["return"]=true,["then"]=true,["true"]=true,["until"]=true,["while"]=true}local x={["\""]="string double",["'"]="string single",["-"]="got -",["."]="got .",["0"]="got 0",["<"]="got <",[">"]="got >",["/"]="got /",[":"]="got :",["="]="got =",["~"]="got ~",["["]="got ["}for y=string.byte("a"),string.byte("z")do x[string.char(y)]="identifier"end;for y=string.byte("A"),string.byte("Z")do x[string.char(y)]="identifier"end;x["_"]="identifier"for y=string.byte("1"),string.byte("9")do x[string.char(y)]="number dec"end;local z={}for y=string.byte("a"),string.byte("z")do z[string.char(y)]=true end;for y=string.byte("A"),string.byte("Z")do z[string.char(y)]=true end;for y=string.byte("0"),string.byte("9")do z[string.char(y)]=true end;z["_"]=true;local A={}for y=string.byte("0"),string.byte("9")do A[string.char(y)]=true end;local B={}for y=string.byte("0"),string.byte("9")do B[string.char(y)]=true end;for y=string.byte("a"),string.byte("f")do B[string.char(y)]=true end;for y=string.byte("A"),string.byte("F")do B[string.char(y)]=true end;local C={}local D={"[","]","(",")","{","}",",",";","?"}for E,y in ipairs(D)do C[y]=y end;for E,y in ipairs({"#","+","*","|","&","%","^"})do C[y]="op"end;local F={}for E,y in ipairs({" ","\t","\v","\n","\r"})do F[y]=true end;local G={a=true,b=true,f=true,n=true,r=true,t=true,v=true,z=true,["\\"]=true,["\'"]=true,["\""]=true,["\r"]=true,["\n"]=true}local function H(I,J,y)if G[y]then return 0,true elseif y=="x"then return 2,B[I:sub(J+1,J+1)]and B[I:sub(J+2,J+2)]elseif y=="u"then if I:sub(J+1,J+1)=="{"then local b=J+2;if not B[I:sub(b,b)]then return 2,false end;while true do b=b+1;y=I:sub(b,b)if not B[y]then return b-J,y=="}"end end end elseif A[y]then local K=A[I:sub(J+1,J+1)]and(A[I:sub(J+2,J+2)]and 2 or 1)or 0;return K,tonumber(I:sub(J,J+K))<256 else return 0,false end end;h.lex=function(I,L)local M={}local N="any"local O=true;local P=1;local Q=0;local J=0;local R=0;local S=0;local T=0;local U=0;local V={}local W=0;local X;local Y;local Z;local _=false;local function a0()X=Q;Y=P;Z=J;_=true end;local function a1(a2,a3)W=W+1;M[W]={x=X,y=Y,tk=a3,kind=a2}_=false end;local function a4()local a3=I:sub(Z,J-1)W=W+1;M[W]={x=X,y=Y,tk=a3,kind=w[a3]and"keyword"or"identifier"}_=false end;local function a5(a2)local a3=I:sub(Z,J-1)W=W+1;M[W]={x=X,y=Y,tk=a3,kind=a2}_=false end;local function a6(a2)local a3=I:sub(Z,J)W=W+1;M[W]={x=X,y=Y,tk=a3,kind=a2}_=false end;local function a7()_=false end;local function a8(a9)local aa=M[W]table.insert(V,{filename=L,y=aa.y,x=aa.x,msg=a9 or"invalid token '"..aa.tk.."'"})end;local K=#I;if I:sub(1,2)=="#!"then a0()J=I:find("\n")if not J then J=K+1 end;a5("hashbang")P=2;Q=0 end;N="any"while J<=K do if O then J=J+1;if J>K then break end end;local y=I:sub(J,J)if O then if y=="\n"then P=P+1;Q=0 else Q=Q+1 end else O=true end;if N=="any"then local ab=x[y]if ab then N=ab;a0()else local ac=C[y]if ac then a0()a1(ac,y)elseif not F[y]then a0()a6("$ERR$")a8()end end elseif N=="identifier"then if not z[y]then a4()O=false;N="any"end elseif N=="string double"then if y=="\\"then N="string double got \\"elseif y=="\""then a6("string")N="any"end elseif N=="comment short"then if y=="\n"then N="any"end elseif N=="got ="then local aa;if y=="="then aa="=="else aa="="O=false end;a1("op",aa)N="any"elseif N=="got ."then if y=="."then N="got .."elseif A[y]then N="number decfloat"else a1(".",".")O=false;N="any"end elseif N=="got :"then local aa;if y==":"then aa="::"else aa=":"O=false end;a1(aa,aa)N="any"elseif N=="got ["then if y=="["then N="string long"elseif y=="="then T=T+1 else a1("[","[")O=false;N="any"T=0 end elseif N=="number dec"then if A[y]then elseif y=="."then N="number decfloat"elseif y=="e"or y=="E"then N="number powersign"else a5("integer")O=false;N="any"end elseif N=="got -"then if y=="-"then N="got --"else a1("op","-")O=false;N="any"end elseif N=="got .."then if y=="."then a1("...","...")else a1("op","..")O=false end;N="any"elseif N=="number hex"then if B[y]then elseif y=="."then N="number hexfloat"elseif y=="p"or y=="P"then N="number powersign"else a5("integer")O=false;N="any"end elseif N=="got --"then if y=="["then N="got --["elseif y=="#"then N="pragma"else O=false;N="comment short"a7()end elseif N=="pragma"then if not z[y]then a5("pragma")if M[W].tk=="--#pragma"then N="pragma any"else N="comment short"table.remove(M)W=W-1;a7()end;O=false end elseif N=="pragma any"then if y=="\n"then N="any"elseif z[y]then N="pragma word"a0()elseif not F[y]then a0()a6("$ERR$")a8()end elseif N=="pragma word"then if not z[y]then a5("pragma_identifier")O=false;N=y=="\n"and"any"or"pragma any"end elseif N=="got 0"then if y=="x"or y=="X"then N="number hex"elseif y=="e"or y=="E"then N="number powersign"elseif A[y]then N="number dec"elseif y=="."then N="number decfloat"else a5("integer")O=false;N="any"end elseif N=="got --["then if y=="["then N="comment long"elseif y=="="then R=R+1 else O=false;N="comment short"a7()R=0 end elseif N=="comment long"then if y=="]"then N="comment long got ]"end elseif N=="comment long got ]"then if y=="]"and S==R then a7()N="any"R=0;S=0 elseif y=="="then S=S+1 else N="comment long"S=0 end elseif N=="string double got \\"then local r,ad=H(I,J,y)J=J+r;if not ad then a6("$ERR$")a8("malformed string")end;Q=Q+r;N="string double"elseif N=="string single"then if y=="\\"then N="string single got \\"elseif y=="'"then a6("string")N="any"end elseif N=="string single got \\"then local r,ad=H(I,J,y)J=J+r;if not ad then a6("$ERR$")a8("malformed string")end;Q=Q+r;N="string single"elseif N=="got ~"then local aa;if y=="="then aa="~="else aa="~"O=false end;a1("op",aa)N="any"elseif N=="got <"then local aa;if y=="="then aa="<="elseif y=="<"then aa="<<"else aa="<"O=false end;a1("op",aa)N="any"elseif N=="got >"then local aa;if y=="="then aa=">="elseif y==">"then aa=">>"else aa=">"O=false end;a1("op",aa)N="any"elseif N=="got /"then local aa;if y=="/"then aa="//"else aa="/"O=false end;a1("op",aa)N="any"elseif N=="string long"then if y=="]"then N="string long got ]"end elseif N=="string long got ]"then if y=="]"then if U==T then a6("string")N="any"T=0;U=0 end elseif y=="="then U=U+1 else N="string long"U=0 end elseif N=="number hexfloat"then if y=="p"or y=="P"then N="number powersign"elseif not B[y]then a5("number")O=false;N="any"end elseif N=="number decfloat"then if y=="e"or y=="E"then N="number powersign"elseif not A[y]then a5("number")O=false;N="any"end elseif N=="number powersign"then if y=="-"or y=="+"then N="number power"elseif A[y]then N="number power"else a6("$ERR$")a8("malformed number")N="any"end elseif N=="number power"then if not A[y]then a5("number")O=false;N="any"end end end;if _ then if v[N]then a5(v[N])if v[N]=="$ERR$"then local ae=N:sub(1,6)if ae=="string"then a8("malformed string")elseif ae=="number"then a8("malformed number")elseif ae=="commen"then a8("unfinished long comment")else a8()end elseif w[M[W].tk]then M[W].kind="keyword"end else a7()end end;table.insert(M,{x=Q+1,y=P,i=J,tk="$EOF$",kind="$EOF$"})return M,V end end;local function af(ag,ah,ai)local K=#ag;local aj;local ak,al=1,K;while ak<=al do aj=math.floor((ak+al)/2)local am=ag[aj]local an=ai(am,ah)if an then if aj==K then return aj,am else if not ai(ag[aj+1],ah)then return aj,am end end;ak=aj+1 else al=aj-1 end end end;h.get_token_at=function(ao,P,Q)local E,ap=af(ao,nil,function(a3)return a3.y<P or a3.y==P and a3.x<=Q end)if ap and ap.y==P and ap.x<=Q and Q<ap.x+#ap.tk then return ap.tk end end;local aq=0;local function ar()aq=aq+1;return aq end;local as={["array"]=true,["map"]=true,["record"]=true,["interface"]=true,["self"]=true,["emptytable"]=true,["tupletable"]=true,["generic"]=false,["typedecl"]=false,["typevar"]=false,["typearg"]=false,["function"]=false,["enum"]=false,["boolean"]=false,["string"]=false,["nil"]=false,["thread"]=false,["number"]=false,["integer"]=false,["union"]=false,["nominal"]=false,["literal_table_item"]=false,["unresolved_emptytable_value"]=false,["unresolved_typearg"]=false,["unresolvable_typearg"]=false,["circular_require"]=false,["boolean_context"]=false,["tuple"]=false,["poly"]=false,["any"]=false,["unknown"]=false,["invalid"]=false,["none"]=false,["*"]=false}local function at(aa)return aa.typename=="number"or aa.typename=="integer"end;local au={}local av={}local aw={}local ax={}local ay={}local az={}local aA={["const"]=true,["close"]=true,["total"]=true}local aB=aA;local aC={ExpectedContext={}}local aD;local aE={__tostring=function(aa)return aD(aa)end}local function aF(aG,aH,aa)aa.typeid=ar()aa.f=aG.f;aa.x=aG.x;aa.y=aG.y;aa.typename=aH;do local Y=aa;setmetatable(Y,aE)end;return aa end;local function aI(aG,aa,aH)aa.typeid=ar()aa.f=aG.f;aa.x=aG.x;aa.y=aG.y;aa.typename=aH;setmetatable(aa,aE)return aa end;local function aJ(aG,aa)assert(aa.min_arity)return aF(aG,"function",aa)end;local function aK(aG,aa)local aL=aF(aG,"tuple",{tuple=aa})aL.is_va=true;return aL end;local aM;local function aN(aa)local aO={}for ac,aP in pairs(aa)do aO[ac]=aP end;aO.typeid=ar()do local Y=aO;setmetatable(Y,aE)end;return aO end;local function aQ(aa)local aO={}for ac,aP in pairs(aa)do aO[ac]=aP end;return aO end;local function aR(aS)local aT={}local aU,aV=0,0;for J,aW in ipairs(aS)do aW.i=J end;table.sort(aS,function(aX,aY)local aZ=assert(aX.filename)local a_=assert(aY.filename)return aZ<a_ or aZ==a_ and(aX.y<aY.y or aX.y==aY.y and(aX.x<aY.x or aX.x==aY.x and aX.i<aY.i))end)for J,aW in ipairs(aS)do aW.i=nil;if aW.x==aU and aW.y==aV then table.insert(aT,J)end;aU,aV=aW.x,aW.y end;for J=#aT,1,-1 do table.remove(aS,aT[J])end end;local b0={["nil"]=true,["any"]=true,["number"]=true,["string"]=true,["thread"]=true,["boolean"]=true,["integer"]=true,["self"]=true}local function b1(b2)if not(b2.e1 and b2.e2)then return nil end;if b2.op and b2.op.op=="."then return b1(b2.e1)elseif b2.e1.kind=="variable"and b2.e1.tk=="require"and b2.e2.kind=="expression_list"and#b2.e2==1 and b2.e2[1].kind=="string"then return b2.e2[1].conststr end;return nil end;local function b3(b4)return b4.kind=="op"and b4.op.op=="@funcall"end;do local b5;local b6;local b7;local b8;local b9;local ba;local bb;local bc;local bd;local be;local bf;local bg;local bh;local function bi(bj,J,a9)if not bj.tokens[J]then local bk=bj.tokens[#bj.tokens]table.insert(bj.errs,{filename=bj.filename,y=bk.y,x=bk.x,msg=a9 or"unexpected end of file"})return#bj.tokens end;table.insert(bj.errs,{filename=bj.filename,y=bj.tokens[J].y,x=bj.tokens[J].x,msg=assert(a9,"syntax error, but no error message provided")})return math.min(#bj.tokens,J+1)end;local function bl(b4,a3)b4.yend=a3.y;b4.xend=a3.x+#a3.tk-1 end;local function bm(bj,J,a3)if bj.tokens[J].tk==a3 then return J+1 end;return bi(bj,J,"syntax error, expected '"..a3 .."'")end;local function bn(bj,J,bo,b4)if bj.tokens[J].tk=="end"then local bp,bq=bj.tokens[J].y,bj.tokens[J].x;b4.yend=bp;b4.xend=bq+2;if b4.kind~="function"and bp~=b4.y and bq~=b4.x then if not bj.end_alignment_hint then bj.end_alignment_hint={filename=bj.filename,y=b4.y,x=b4.x,msg="syntax error hint: construct starting here is not aligned with its 'end' at "..bj.filename..":"..bp..":"..bq..":"}end end;return J+1 end;bl(b4,bj.tokens[J])if bj.end_alignment_hint then table.insert(bj.errs,bj.end_alignment_hint)bj.end_alignment_hint=nil end;return bi(bj,J,"syntax error, expected 'end' to close construct started at "..bj.filename..":"..bj.tokens[bo].y..":"..bj.tokens[bo].x..":")end;local br={__tostring=function(b2)return b2.f..":"..b2.y..":"..b2.x.." "..b2.kind end}local function bs(bj,J,a2)local aa=bj.tokens[J]return setmetatable({f=bj.filename,y=aa.y,x=aa.x,tk=aa.tk,kind=a2 or aa.kind},br)end;local function bt(bj,J,aH)local bu=bj.tokens[J]local aa=setmetatable({},aE)aa.typeid=ar()aa.f=bj.filename;aa.x=bu.x;aa.y=bu.y;aa.typename=aH;return aa end;local function bv(bj,J,bw)return bt(bj,J,bw)end;local function bx(bj,J,by,aL)local bz=bt(bj,J,"generic")bz.typeargs=by;bz.t=aL;return bz end;local function bA(bj,J,bB)local aa=bt(bj,J,"typedecl")aa.def=bB;return aa end;local function bC(bj,J,bD,bE)local aa=bt(bj,J,"tuple")aa.is_va=bE;aa.tuple=bD or{}return aa,aa.tuple end;local function bF(bj,J,u)local aa=bt(bj,J,"nominal")if u then aa.names={u}end;return aa end;local function bG(bj,J,a2,bH)if bj.tokens[J].kind==a2 then return J+1,bs(bj,J,bH)end;return bi(bj,J,"syntax error, expected "..a2)end;local function r(bj,J,bI)local bJ={filename=bj.filename,tokens=bj.tokens,errs={},required_modules={},parse_lang=bj.parse_lang}return bI(bJ,J)end;local function bK(bj,J,a9,bI,bL)local bM=r(bj,bL or J,bI)bi(bj,J,a9)return bM end;local function bN(bj,J,bo,b4,bw)local by;local bB;J,by=b6(bj,J)bB=bv(bj,bo,bw)local bO;J,bO=bh[bw](bj,J,bB)if not bO then return bi(bj,J,"expected a type")end;J=bn(bj,J,bo,b4)if by then return J,bx(bj,bo,by,bB)end;return J,bB end;local function bP(bj,J)local bw=bj.tokens[J].tk;J=J+1;assert(bh[bw],bw.." has no parse body function")local bQ,bR=bN(bj,J,J-1,{},bw)return bQ,not not bR end;local function bS(bj,J)local bT=bj.tokens[J].tk;if bT=="record"or bT=="interface"then local bM,al=r(bj,J,bP)if al then bi(bj,J,bT=="record"and"syntax error: this syntax is no longer valid; declare nested record inside a record"or"syntax error: cannot declare interface inside a table; use a statement")return bM,bs(bj,J,"error_node")end elseif bT=="enum"and bj.tokens[J+1].kind=="string"then J=bK(bj,J,"syntax error: this syntax is no longer valid; declare nested enum inside a record",bP)return J,bs(bj,J-1,"error_node")end;local al;J,al=b7(bj,J)if not al then al=bs(bj,J-1,"error_node")end;return J,al end;local function bU(bj,J,b2)local b4=bs(bj,J,"literal_table_item")if bj.tokens[J].kind=="$EOF$"then return bi(bj,J,"unexpected eof")end;if bj.tokens[J].tk=="["then b4.key_parsed="long"J=J+1;J,b4.key=b8(bj,J,"]")J=bm(bj,J,"=")J,b4.value=bS(bj,J)return J,b4,b2 elseif bj.tokens[J].kind=="identifier"then if bj.tokens[J+1].tk=="="then b4.key_parsed="short"J,b4.key=bG(bj,J,"identifier","string")b4.key.conststr=b4.key.tk;b4.key.tk='"'..b4.key.tk..'"'J=bm(bj,J,"=")J,b4.value=bS(bj,J)return J,b4,b2 elseif bj.tokens[J+1].tk==":"then b4.key_parsed="short"local bV=J;local bW={filename=bj.filename,tokens=bj.tokens,errs={},required_modules=bj.required_modules,parse_lang=bj.parse_lang}J,b4.key=bG(bW,J,"identifier","string")b4.key.conststr=b4.key.tk;b4.key.tk='"'..b4.key.tk..'"'J=bm(bW,J,":")J,b4.itemtype=bc(bW,J)if b4.itemtype and bj.tokens[J].tk=="="then J=bm(bW,J,"=")J,b4.value=bS(bW,J)if b4.value then for E,al in ipairs(bW.errs)do table.insert(bj.errs,al)end;return J,b4,b2 end end;b4.itemtype=nil;J=bV end end;b4.key=bs(bj,J,"integer")b4.key_parsed="implicit"b4.key.constnum=b2;b4.key.tk=tostring(b2)J,b4.value=b7(bj,J)if not b4.value then return bi(bj,J,"expected an expression")end;return J,b4,b2+1 end;local function bX(bj,J,ag,bY,bZ,b_)local b2=1;while bj.tokens[J].kind~="$EOF$"do if bY[bj.tokens[J].tk]then bl(ag,bj.tokens[J])break end;local ah;local c0=b2;J,ah,b2=b_(bj,J,b2)b2=b2 or c0;table.insert(ag,ah)if bj.tokens[J].tk==","then J=J+1;if bZ=="sep"and bY[bj.tokens[J].tk]then bi(bj,J,"unexpected '"..bj.tokens[J].tk.."'")return J,ag end elseif bZ=="term"and bj.tokens[J].tk==";"then J=J+1 elseif not bY[bj.tokens[J].tk]then local c1={}for ac,E in pairs(bY)do table.insert(c1,"'"..ac.."'")end;table.sort(c1)local c2=c1[1]:sub(2,-2)local a9;if c2==")"and bj.tokens[J].tk=="="then a9="syntax error, cannot perform an assignment here (did you mean '=='?)"J=bK(bj,J,a9,b7,J+1)else table.insert(c1,"','")a9="syntax error, expected one of: "..table.concat(c1,", ")bi(bj,J,a9)end;if c2~="}"and bj.tokens[J].y~=bj.tokens[J-1].y then table.insert(bj.tokens,J,{tk=c2,y=bj.tokens[J-1].y,x=bj.tokens[J-1].x+1,kind="keyword"})return J,ag end end end;return J,ag end;local function c3(bj,J,ag,c4,bY,bZ,b_)J=bm(bj,J,c4)J=bX(bj,J,ag,{[bY]=true},bZ,b_)J=bm(bj,J,bY)return J,ag end;local function c5(bj,J)local b4=bs(bj,J,"literal_table")return c3(bj,J,b4,"{","}","term",bU)end;local function c6(bj,J,ag,b_,c7)local bW={filename=bj.filename,tokens=bj.tokens,errs={},required_modules=bj.required_modules,parse_lang=bj.parse_lang}local c8,ah=b_(bW,J)if not ah then return J,ag end;for E,al in ipairs(bW.errs)do table.insert(bj.errs,al)end;J=c8;table.insert(ag,ah)while bj.tokens[J].tk==","and(not c7 or not(bj.tokens[J+1].kind=="identifier"and bj.tokens[J+2]and bj.tokens[J+2].tk==":"))do J=J+1;J,ah=b_(bj,J)table.insert(ag,ah)end;return J,ag end;local function c9(bj,J,b_)if bj.tokens[J+1].tk==">"then return bi(bj,J+1,"type argument list cannot be empty")end;local bD={}J=bm(bj,J,"<")J=bX(bj,J,bD,{[">"]=true,[">>"]=true},"sep",b_)if bj.tokens[J].tk==">"then J=J+1 elseif bj.tokens[J].tk==">>"then bj.tokens[J].tk=">"else return bi(bj,J,"syntax error, expected '>'")end;return J,bD end;local function ca(bj,J)local u=bj.tokens[J].tk;local cb;local aa=bt(bj,J,"typearg")J=bG(bj,J,"identifier")if bj.tokens[J].tk=="is"then J=J+1;J,cb=be(bj,J)end;aa.typearg=u;aa.constraint=cb;return J,aa end;local function cc(bj,J)local cd=J-1;local aa;J,aa=b5(bj,J,"rets")if#aa.tuple==0 then aa.x=bj.tokens[cd].x;aa.y=bj.tokens[cd].y end;return J,aa end;b6=function(bj,J)if bj.tokens[J].tk=="<"then return c9(bj,J,ca)end;return J end;local function ce(bj,J)local by;local aL=bt(bj,J,"function")J=J+1;J,by=b6(bj,J)if bj.tokens[J].tk=="("then J,aL.args,aL.maybe_method,aL.min_arity=bb(bj,J)J,aL.rets=cc(bj,J)else aL.args=bC(bj,J,{bt(bj,J,"any")},true)aL.rets=bC(bj,J,{bt(bj,J,"any")},true)aL.is_method=false;aL.min_arity=0 end;if by then return J,bx(bj,J,by,aL)end;return J,aL end;local function cf(bj,J)local a3=bj.tokens[J].tk;local ab=b0[a3]if ab then return J+1,bt(bj,J,a3)elseif a3=="table"and bj.tokens[J+1].tk~="."then local aL=bt(bj,J,"map")aL.keys=bt(bj,J,"any")aL.values=bt(bj,J,"any")return J+1,aL end;local aL=bF(bj,J,a3)J=J+1;while bj.tokens[J].tk=="."do J=J+1;if bj.tokens[J].kind=="identifier"then table.insert(aL.names,bj.tokens[J].tk)J=J+1 else return bi(bj,J,"syntax error, expected identifier")end end;if bj.tokens[J].tk=="<"then J,aL.typevals=c9(bj,J,bc)end;return J,aL end;local function cg(bj,J)local a3=bj.tokens[J].tk;if bj.tokens[J].kind=="identifier"then return cf(bj,J)elseif a3=="{"then local bo=J;J=J+1;local aa;J,aa=bc(bj,J)if not aa then return J end;if bj.tokens[J].tk=="}"then local ch=bt(bj,bo,"array")ch.elements=aa;bl(ch,bj.tokens[J])J=bm(bj,J,"}")return J,ch elseif bj.tokens[J].tk==","then local ch=bt(bj,bo,"tupletable")ch.types={aa}local b2=2;repeat J=J+1;J,ch.types[b2]=bc(bj,J)if not ch.types[b2]then break end;b2=b2+1 until bj.tokens[J].tk~=","bl(ch,bj.tokens[J])J=bm(bj,J,"}")return J,ch elseif bj.tokens[J].tk==":"then local ch=bt(bj,bo,"map")J=J+1;ch.keys=aa;J,ch.values=bc(bj,J)if not ch.values then return J end;bl(ch,bj.tokens[J])J=bm(bj,J,"}")return J,ch end;return bi(bj,J,"syntax error; did you forget a '}'?")elseif a3=="function"then return ce(bj,J)elseif a3=="nil"then return J+1,bt(bj,J,"nil")end;return bi(bj,J,"expected a type")end;bc=function(bj,J)if bj.tokens[J].tk=="("then J=J+1;local aa;J,aa=bc(bj,J)J=bm(bj,J,")")return J,aa end;local ci;local bo=J;J,ci=cg(bj,J)if not ci then return J end;if bj.tokens[J].tk=="|"then local cj=bt(bj,bo,"union")cj.types={ci}while bj.tokens[J].tk=="|"do J=J+1;J,ci=cg(bj,J)if not ci then return J end;table.insert(cj.types,ci)end;ci=cj end;return J,ci end;b5=function(bj,J,ck)local aa,ag=bC(bj,J)local cl=bj.tokens[J].tk;if ck=="rets"or ck=="decltuple"then if cl==":"then J=J+1 else return J,aa end end;local cm=false;if bj.tokens[J].tk=="("then cm=true;J=J+1 end;local cn=J;J=c6(bj,J,ag,bc,ck=="rets")if J==cn and bj.tokens[J].tk~=")"then bi(bj,J-1,"expected a type list")end;if ck=="rets"and bj.tokens[J].tk=="..."then J=J+1;local co=#ag;if co>0 then aa.is_va=true else bi(bj,J,"unexpected '...'")end end;if cm then J=bm(bj,J,")")end;return J,aa end;local function cp(bj,J,b4)local bo=J-1;J,b4.typeargs=b6(bj,J)J,b4.args,b4.min_arity=ba(bj,J)J,b4.rets=cc(bj,J)J,b4.body=b9(bj,J)bl(b4,bj.tokens[J])J=bn(bj,J,bo,b4)return J,b4 end;local function cq(bj,J)local b4=bs(bj,J,"function")J=bm(bj,J,"function")return cp(bj,J,b4)end;local function cr(cs)local ct=cs:sub(1,1)if ct=='"'or ct=="'"then return cs:sub(2,-2),false end;ct=cs:match("^%[=*%[")local cu=#ct+1;return cs:sub(cu,-cu),true end;local function cv(bj,J)local a3=bj.tokens[J].tk;local a2=bj.tokens[J].kind;if a2=="identifier"then return bG(bj,J,"identifier","variable")elseif a2=="string"then local b4=bs(bj,J,"string")b4.conststr,b4.is_longstring=cr(a3)return J+1,b4 elseif a2=="number"or a2=="integer"then local b2=tonumber(a3)local b4;J,b4=bG(bj,J,a2)b4.constnum=b2;return J,b4 elseif a3=="true"then return bG(bj,J,"keyword","boolean")elseif a3=="false"then return bG(bj,J,"keyword","boolean")elseif a3=="nil"then return bG(bj,J,"keyword","nil")elseif a3=="function"then return cq(bj,J)elseif a3=="{"then return c5(bj,J)elseif a2=="..."then return bG(bj,J,"...")elseif a2=="$ERR$"then return bi(bj,J,"invalid token")end;return bi(bj,J,"syntax error")end;local function cw(b2)local cx=b1(b2)if cx then return cx end;if b3(b2)and b2.e1 and b2.e1.tk=="pcall"and b2.e2 and#b2.e2==2 and b2.e2[1].kind=="variable"and b2.e2[1].tk=="require"and b2.e2[2].kind=="string"and b2.e2[2].conststr then return b2.e2[2].conststr end;return nil end;do local cy={[1]={["not"]=11,["#"]=11,["-"]=11,["~"]=11},[2]={["or"]=1,["and"]=2,["is"]=3,["<"]=3,[">"]=3,["<="]=3,[">="]=3,["~="]=3,["=="]=3,["|"]=4,["~"]=5,["&"]=6,["<<"]=7,[">>"]=7,[".."]=8,["+"]=9,["-"]=9,["*"]=10,["/"]=10,["//"]=10,["%"]=10,["^"]=12,["as"]=50,["@funcall"]=100,["@index"]=100,["."]=100,[":"]=100}}local cz={["^"]=true,[".."]=true}local function cA(a3,cB,cC)return{y=a3.y,x=a3.x,arity=cB,op=cC,prec=cy[cB][cC]}end;aM=function(b4,cB,cC)return{y=b4.y,x=b4.x,arity=cB,op=cC,prec=cy[cB][cC]}end;local cD={["("]=true,["{"]=true,["string"]=true}local cE;local function cF(bj,cG,J)return bj.tokens[J-1].kind==")"or cG.kind=="op"and(cG.op.op=="@funcall"or cG.op.op=="@index"or cG.op.op=="."or cG.op.op==":")or cG.kind=="identifier"or cG.kind=="variable"end;local function cH(bj,cI,cJ)return{f=bj.filename,y=cI.y,x=cI.x,kind="paren",e1=cJ,failstore=true}end;local function cK(bj,J)if bj.tokens[J].kind=="$EOF$"then return J end;local cJ;local cL=bj.tokens[J]if cy[1][cL.tk]~=nil then local cC=cA(cL,1,cL.tk)J=J+1;local cn=J;J,cJ=cK(bj,J)if not cJ then bi(bj,cn,"expected an expression")return J end;cJ={f=bj.filename,y=cL.y,x=cL.x,kind="op",op=cC,e1=cJ}elseif bj.tokens[J].tk=="("then J=J+1;local cn=J;J,cJ=b8(bj,J,")")if not cJ then bi(bj,cn,"expected an expression")return J end;cJ={f=bj.filename,y=cL.y,x=cL.x,kind="paren",e1=cJ}else J,cJ=cv(bj,J)end;if not cJ then return J end;while true do local cI=bj.tokens[J]if cI.kind==","or cI.kind==")"then break end;if cI.tk=="."or cI.tk==":"then local cC=cA(cI,2,cI.tk)local cn=J;local cM;J=J+1;if bj.tokens[J].kind~="identifier"then local cN=r(bj,J,bc)if cN>J+1 then bi(bj,J,"syntax error, cannot declare a type here (missing 'local' or 'global'?)")return cN,cH(bj,cI,cJ)end end;J,cM=bG(bj,J,"identifier")if not cM then return J,cH(bj,cI,cJ)end;if cC.op==":"then if not cD[bj.tokens[J].kind]then if bj.tokens[J].tk=="="then bi(bj,J,"syntax error, cannot perform an assignment here (missing 'local' or 'global'?)")else bi(bj,J,"expected a function call for a method")end;return J,cH(bj,cI,cJ)end;if not cF(bj,cJ,cn)then bi(bj,cn,"cannot call a method on this expression")return J,cH(bj,cI,cJ)end end;cJ={f=bj.filename,y=cI.y,x=cI.x,kind="op",op=cC,e1=cJ,e2=cM}elseif cI.tk=="("then local cO=bj.tokens[J-1]if cI.y>cO.y and bj.parse_lang~="lua"then table.insert(bj.tokens,J,{y=cO.y,x=cO.x+#cO.tk,tk=";",kind=";"})break end;local cC=cA(cI,2,"@funcall")local cn=J;local cP=bs(bj,J,"expression_list")J,cP=c3(bj,J,cP,"(",")","sep",b7)if not cF(bj,cJ,cn)then bi(bj,cn,"cannot call this expression")return J,cH(bj,cI,cJ)end;cJ={f=bj.filename,y=cP.y,x=cP.x,kind="op",op=cC,e1=cJ,e2=cP}table.insert(bj.required_modules,cw(cJ))elseif cI.tk=="["then local cC=cA(cI,2,"@index")local cn=J;local cQ;J=J+1;J,cQ=b8(bj,J,"]")if not cF(bj,cJ,cn)then bi(bj,cn,"cannot index this expression")return J,cH(bj,cI,cJ)end;cJ={f=bj.filename,y=cI.y,x=cI.x,kind="op",op=cC,e1=cJ,e2=cQ}elseif cI.kind=="string"or cI.kind=="{"then local cC=cA(cI,2,"@funcall")local cn=J;local cP=bs(bj,J,"expression_list")local cR;if cI.kind=="string"then cR=bs(bj,J)cR.conststr=cr(cI.tk)J=J+1 else J,cR=c5(bj,J)end;if not cF(bj,cJ,cn)then if cI.kind=="string"then bi(bj,cn,"cannot use a string here; if you're trying to call the previous expression, wrap it in parentheses")else bi(bj,cn,"cannot use a table here; if you're trying to call the previous expression, wrap it in parentheses")end;return J,cH(bj,cI,cJ)end;table.insert(cP,cR)cJ={f=bj.filename,y=cP.y,x=cP.x,kind="op",op=cC,e1=cJ,e2=cP}table.insert(bj.required_modules,cw(cJ))elseif cI.tk=="as"or cI.tk=="is"then local cC=cA(cI,2,cI.tk)J=J+1;local cS=bs(bj,J,"cast")if bj.tokens[J].tk=="("then J,cS.casttype=b5(bj,J,"casttype")else J,cS.casttype=bc(bj,J)end;if not cS.casttype then return J,cH(bj,cI,cJ)end;cJ={f=bj.filename,y=cI.y,x=cI.x,kind="op",op=cC,e1=cJ,e2=cS,conststr=cJ.conststr}else break end end;return J,cJ end;cE=function(bj,J,cT,cU)local cV=bj.tokens[J].tk;while cy[2][cV]and cy[2][cV]>=cU do local cL=bj.tokens[J]local cC=cA(cL,2,cL.tk)J=J+1;local cW;J,cW=cK(bj,J)if not cW then bi(bj,J,"expected an expression")return J end;cV=bj.tokens[J].tk;while cy[2][cV]and(cy[2][cV]>cy[2][cC.op]or cz[cV]and cy[2][cV]==cy[2][cC.op])do J,cW=cE(bj,J,cW,cy[2][cV])if not cW then bi(bj,J,"expected an expression")return J end;cV=bj.tokens[J].tk end;cT={f=bj.filename,y=cL.y,x=cL.x,kind="op",op=cC,e1=cT,e2=cW}end;return J,cT end;b7=function(bj,J)local cT;local bo=J;J,cT=cK(bj,J)if cT then J,cT=cE(bj,J,cT,0)end;if cT then return J,cT,0 end;if J==bo then J=bi(bj,J,"expected an expression")end;return J end end;b8=function(bj,J,a3)local al;J,al=b7(bj,J)if not al then al=bs(bj,J-1,"error_node")end;if bj.tokens[J].tk==a3 then J=J+1 else local a9="syntax error, expected '"..a3 .."'"if bj.tokens[J].tk=="="then a9="syntax error, cannot perform an assignment here (did you mean '=='?)"end;for b2=0,19 do local aa=bj.tokens[J+b2]if aa.kind=="$EOF$"then break end;if aa.tk==a3 then bi(bj,J,a9)return J+b2+1,al end end;J=bi(bj,J,a9)end;return J,al end;local function cX(bj,J)local b4;J,b4=bG(bj,J,"identifier")if not b4 then return J end;if bj.tokens[J].tk=="<"then J=J+1;local cY;J,cY=bG(bj,J,"identifier")if cY then if not aB[cY.tk]then bi(bj,J,"unknown variable annotation: "..cY.tk)end;b4.attribute=cY.tk else bi(bj,J,"expected a variable annotation")end;J=bm(bj,J,">")end;return J,b4 end;local function cZ(bj,J)local b4;if bj.tokens[J].tk=="..."then J,b4=bG(bj,J,"...","argument")b4.opt=true else J,b4=bG(bj,J,"identifier","argument")end;if bj.tokens[J].tk=="..."then bi(bj,J,"'...' needs to be declared as a typed argument")end;if bj.tokens[J].tk=="?"then J=J+1;b4.opt=true end;if bj.tokens[J].tk==":"then J=J+1;local c_;J,c_=bc(bj,J)if b4 then b4.argtype=c_ end end;return J,b4,0 end;ba=function(bj,J)local b4=bs(bj,J,"argument_list")J,b4=c3(bj,J,b4,"(",")","sep",cZ)local d0=false;local d1=0;for aX,d2 in ipairs(b4)do if d2.tk=="..."then if aX~=#b4 then bi(bj,J,"'...' can only be last argument")break end elseif d2.opt then d0=true elseif d0 then return bi(bj,J,"non-optional arguments cannot follow optional arguments")else d1=d1+1 end end;return J,b4,d1 end;local function d3(bj,J)local d4=false;local bE=false;local d5=false;local d6=nil;if bj.tokens[J].kind=="identifier"then d6=bj.tokens[J].tk;if bj.tokens[J+1].tk=="?"then d4=true;if bj.tokens[J+2].tk==":"then J=J+3 end elseif bj.tokens[J+1].tk==":"then J=J+2 end elseif bj.tokens[J].kind=="?"then d4=true;J=J+1 elseif bj.tokens[J].tk=="..."then if bj.tokens[J+1].tk==":"then J=J+2;bE=true else return bi(bj,J,"cannot have untyped '...' when declaring the type of an argument")end end;local aL;J,aL=bc(bj,J)if aL then if not bE and bj.tokens[J].tk=="..."then J=J+1;bE=true end;if d6=="self"then d5=true end end;return J,{i=J,type=aL,is_va=bE,is_self=d5,opt=d4 or bE},0 end;bb=function(bj,J)local d7={}J=c3(bj,J,d7,"(",")","sep",d3)local aa,ag=bC(bj,J)local b2=#d7;local d1=0;for cu,d8 in ipairs(d7)do ag[cu]=d8.type;if d8.is_va and cu<b2 then bi(bj,d8.i,"'...' can only be last argument")end;if not d8.opt then d1=d1+1 end end;if b2>0 and d7[b2].is_va then aa.is_va=true end;return J,aa,b2>0 and d7[1].is_self,d1 end;local function d9(bj,J)if bj.tokens[J].kind=="identifier"then return J+1,bs(bj,J,"identifier")end;J=bi(bj,J,"syntax error, expected identifier")return J,bs(bj,J,"error_node")end;local function da(bj,J)J=bm(bj,J,"local")J=bm(bj,J,"function")local b4=bs(bj,J-2,"local_function")J,b4.name=d9(bj,J)return cp(bj,J,b4)end;local function db(bj,J,dc)local bV=J;J=bm(bj,J,"function")local dd=bs(bj,J-1,"global_function")local de={}J,de[1]=d9(bj,J)while bj.tokens[J].tk=="."do J=J+1;J,de[#de+1]=d9(bj,J)end;if bj.tokens[J].tk==":"then J=J+1;J,de[#de+1]=d9(bj,J)dd.is_method=true end;if#de>1 then dd.kind="record_function"local df=de[1]df.kind="type_identifier"for dg=2,#de-1 do local dh=aM(de[dg],2,".")de[dg].kind="identifier"df={f=bj.filename,y=de[dg].y,x=de[dg].x,kind="op",op=dh,e1=df,e2=de[dg]}end;dd.fn_owner=df end;dd.name=de[#de]local di,dj=bj.tokens[J].x,bj.tokens[J].y;J=cp(bj,J,dd)if dd.is_method and dd.args then table.insert(dd.args,1,{f=bj.filename,x=di,y=dj,tk="self",kind="identifier",is_self=true})dd.min_arity=dd.min_arity+1 end;if not dd.name then return bV+1 end;if dd.kind=="record_function"and dc=="global"then bi(bj,bV,"record functions cannot be annotated as 'global'")elseif dd.kind=="global_function"and dc=="record"then dd.implicit_global_function=true end;return J,dd end;local function dk(bj,J,b2,b4,dl)local dm=bs(bj,J,"if_block")J=J+1;dm.if_parent=b4;dm.if_block_n=b2;if not dl then J,dm.exp=b8(bj,J,"then")if not dm.exp then return J end end;J,dm.body=b9(bj,J)if not dm.body then return J end;dm.yend,dm.xend=dm.body.yend,dm.body.xend;table.insert(b4.if_blocks,dm)return J,b4 end;local function dn(bj,J)local bo=J;local b4=bs(bj,J,"if")b4.if_blocks={}J,b4=dk(bj,J,1,b4)if not b4 then return J end;local b2=2;while bj.tokens[J].tk=="elseif"do J,b4=dk(bj,J,b2,b4)if not b4 then return J end;b2=b2+1 end;if bj.tokens[J].tk=="else"then J,b4=dk(bj,J,b2,b4,true)if not b4 then return J end end;J=bn(bj,J,bo,b4)return J,b4 end;local function dp(bj,J)local bo=J;local b4=bs(bj,J,"while")J=bm(bj,J,"while")J,b4.exp=b8(bj,J,"do")J,b4.body=b9(bj,J)J=bn(bj,J,bo,b4)return J,b4 end;local function dq(bj,J)local bo=J;local b4=bs(bj,J,"fornum")J=J+1;J,b4.var=d9(bj,J)J=bm(bj,J,"=")J,b4.from=b8(bj,J,",")J,b4.to=b7(bj,J)if bj.tokens[J].tk==","then J=J+1;J,b4.step=b8(bj,J,"do")else J=bm(bj,J,"do")end;J,b4.body=b9(bj,J)J=bn(bj,J,bo,b4)return J,b4 end;local function dr(bj,J)local bo=J;local b4=bs(bj,J,"forin")J=J+1;b4.vars=bs(bj,J,"variable_list")J,b4.vars=bX(bj,J,b4.vars,{["in"]=true},"sep",d9)J=bm(bj,J,"in")b4.exps=bs(bj,J,"expression_list")J=bX(bj,J,b4.exps,{["do"]=true},"sep",b7)if#b4.exps<1 then return bi(bj,J,"missing iterator expression in generic for")elseif#b4.exps>3 then return bi(bj,J,"too many expressions in generic for")end;J=bm(bj,J,"do")J,b4.body=b9(bj,J)J=bn(bj,J,bo,b4)return J,b4 end;local function ds(bj,J)if bj.tokens[J+1].kind=="identifier"and bj.tokens[J+2].tk=="="then return dq(bj,J)else return dr(bj,J)end end;local function dt(bj,J)local b4=bs(bj,J,"repeat")J=bm(bj,J,"repeat")J,b4.body=b9(bj,J)b4.body.is_repeat=true;J=bm(bj,J,"until")J,b4.exp=b7(bj,J)bl(b4,bj.tokens[J-1])return J,b4 end;local function du(bj,J)local bo=J;local b4=bs(bj,J,"do")J=bm(bj,J,"do")J,b4.body=b9(bj,J)J=bn(bj,J,bo,b4)return J,b4 end;local function dv(bj,J)local b4=bs(bj,J,"break")J=bm(bj,J,"break")return J,b4 end;local function dw(bj,J)local b4=bs(bj,J,"goto")J=bm(bj,J,"goto")b4.label=bj.tokens[J].tk;J=bG(bj,J,"identifier")return J,b4 end;local function dx(bj,J)local b4=bs(bj,J,"label")J=bm(bj,J,"::")b4.label=bj.tokens[J].tk;J=bG(bj,J,"identifier")J=bm(bj,J,"::")return J,b4 end;local dy={["end"]=true,["else"]=true,["elseif"]=true,["until"]=true}local dz={[";"]=true,["$EOF$"]=true}for ac,aP in pairs(dy)do dz[ac]=aP end;local function dA(bj,J)local b4=bs(bj,J,"return")J=bm(bj,J,"return")b4.exps=bs(bj,J,"expression_list")J=bX(bj,J,b4.exps,dz,"sep",b7)if bj.tokens[J].kind==";"then J=J+1;if bj.tokens[J].kind~="$EOF$"and not dy[bj.tokens[J].kind]then return bi(bj,J,"return must be the last statement of its block")end end;return J,b4 end;local function dB(bj,J,dC,dD,dE,dF)if not dE[dC]then dE[dC]=dD;table.insert(dF,dC)return true end;local dG=dE[dC]local dH=dG.typename=="generic"and dG.t or dG;local dI=dD.typename=="generic"and dD.t or dD;if dI.typename=="function"then if dH.typename=="function"then local b=bt(bj,J,"poly")b.types={dG,dD}dE[dC]=b;return true elseif dG.typename=="poly"then table.insert(dG.types,dD)return true end end;bi(bj,J,"attempt to redeclare field '"..dC.."' (only functions can be overloaded)")return false end;local function dJ(bB,dK)if bB.typename=="generic"then bB=bB.t end;if bB.typename=="record"or bB.typename=="interface"or bB.typename=="enum"then if not bB.declname then bB.declname=dK end end end;local function dL(bj,J,bB,bw)local bo=J;J=J+1;local dM=J;local aP;J,aP=bG(bj,J,"identifier","type_identifier")if not aP then return bi(bj,J,"expected a variable name")end;local W=bs(bj,bo,"newtype")local dN;J,dN=bN(bj,J,bo,W,bw)if not dN then return J end;dJ(dN,aP.tk)W.newtype=bA(bj,bo,dN)dB(bj,dM,aP.tk,W.newtype,bB.fields,bB.field_order)return J end;bf=function(bj,J,bB)bB.enumset={}while bj.tokens[J].tk~="$EOF$"and bj.tokens[J].tk~="end"do local ah;J,ah=bG(bj,J,"string","string")if ah then bB.enumset[cr(ah.tk)]=true end end;return J,true end;local dO={["__add"]=true,["__sub"]=true,["__mul"]=true,["__div"]=true,["__mod"]=true,["__pow"]=true,["__unm"]=true,["__idiv"]=true,["__band"]=true,["__bor"]=true,["__bxor"]=true,["__bnot"]=true,["__shl"]=true,["__shr"]=true,["__concat"]=true,["__len"]=true,["__eq"]=true,["__lt"]=true,["__le"]=true,["__index"]=true,["__newindex"]=true,["__call"]=true,["__tostring"]=true,["__pairs"]=true,["__gc"]=true,["__close"]=true,["__is"]=true}local function dP(bj,bo,dQ)local b4=bs(bj,bo,"macroexp")local J;if bj.tokens[bo+1].tk=="<"then J,b4.typeargs=c9(bj,bo+1,ca)else J=dQ end;J,b4.args,b4.min_arity=ba(bj,J)J,b4.rets=cc(bj,J)J=bm(bj,J,"return")J,b4.exp=b7(bj,J)bl(b4,bj.tokens[J])J=bn(bj,J,bo,b4)return J,b4 end;local function dR(bj,J,bB)local b4=bs(bj,J,"macroexp")b4.is_method=true;b4.args=bs(bj,J,"argument_list")b4.args[1]=bs(bj,J,"argument")b4.args[1].tk="self"b4.args[1].argtype=bt(bj,J,"self")b4.args[1].argtype.display_type=bB;b4.min_arity=1;b4.rets=bC(bj,J)b4.rets.tuple[1]=bt(bj,J,"boolean")J,b4.exp=b7(bj,J)bl(b4,bj.tokens[J-1])return J,b4 end;be=function(bj,J)local bo=J;local aL;J,aL=cf(bj,J)if not(aL.typename=="nominal")then return bi(bj,bo,"expected an interface")end;return J,aL end;local function dS(bj,J,bB)if bB.interface_list then local c2=bB.interface_list[1]if c2.typename=="array"then return bK(bj,J,"duplicated declaration of array element type",bc)end end;local aa;J,aa=cg(bj,J)if not aa then return J end;if not(aa.typename=="array")then bi(bj,J,"expected an array declaration")return J end;bB.elements=aa.elements;return J,aa end;local function dT(bj,J,bB)for dU=#bB.interface_list,1,-1 do local dV=bB.interface_list[dU]if dV.typename=="nominal"and#dV.names==1 and dV.names[1]=="userdata"then table.remove(bB.interface_list,dU)if bB.is_userdata then bi(bj,J,"duplicated 'userdata' declaration")end;bB.is_userdata=true end end end;bg=function(bj,J,bB)bB.fields={}bB.field_order={}if bj.tokens[J].tk=="{"then local dW;J,dW=dS(bj,J,bB)if dW then bB.interface_list={dW}end end;if bj.tokens[J].tk=="is"then J=J+1;if bj.tokens[J].tk=="{"then local dW;J,dW=dS(bj,J,bB)if bj.tokens[J].tk==","then J=J+1;J,bB.interface_list=c6(bj,J,{},be)else bB.interface_list={}end;if dW then table.insert(bB.interface_list,1,dW)end else J,bB.interface_list=c6(bj,J,{},be)end;if bB.interface_list then dT(bj,J,bB)end end;if bj.tokens[J].tk=="where"then local dX=J;J=J+1;local dY;J,dY=dR(bj,J,bB)local aL=bt(bj,dX,"function")aL.is_method=true;aL.min_arity=1;aL.args=bC(bj,dX,{aF(dY,"self",{display_type=bB})})aL.rets=bC(bj,dX,{bt(bj,dX,"boolean")})aL.macroexp=dY;bB.meta_fields={}bB.meta_field_order={}dB(bj,J,"__is",aL,bB.meta_fields,bB.meta_field_order)end;while not(bj.tokens[J].kind=="$EOF$"or bj.tokens[J].tk=="end")do local bw=bj.tokens[J].tk;if bj.tokens[J].tk=="userdata"and bj.tokens[J+1].tk~=":"then if bB.is_userdata then bi(bj,J,"duplicated 'userdata' declaration")else bB.is_userdata=true end;J=J+1 elseif bj.tokens[J].tk=="{"then return bi(bj,J,"syntax error: this syntax is no longer valid; declare array interface at the top with 'is {...}'")elseif bj.tokens[J].tk=="type"and bj.tokens[J+1].tk~=":"then J=J+1;local dM=J;local dZ;J,dZ=bd(bj,J,"local_type")if not dZ then return bi(bj,J,"expected a type definition")end;local aP=dZ.var;if not aP then return bi(bj,J,"expected a variable name")end;local W=dZ.value;if not W or not W.newtype then return bi(bj,J,"expected a type definition")end;local d_=W.newtype;if d_.is_alias then d_.is_nested_alias=true end;dB(bj,dM,aP.tk,W.newtype,bB.fields,bB.field_order)elseif bh[bw]and bj.tokens[J+1].tk~=":"then if bB.typename=="interface"and bw=="record"then J=bK(bj,J,"interfaces cannot contain record definitions",bP)else J=dL(bj,J,bB,bw)end else local e0=false;if bj.tokens[J].tk=="metamethod"and bj.tokens[J+1].tk~=":"then e0=true;J=J+1 end;local aP;if bj.tokens[J].tk=="["then J,aP=cv(bj,J+1)if aP and not aP.conststr then return bi(bj,J,"expected a string literal")end;J=bm(bj,J,"]")else J,aP=bG(bj,J,"identifier","variable")end;local dM=J;if not aP then return bi(bj,J,"expected a variable name")end;if bj.tokens[J].tk==":"then J=J+1;local aa;J,aa=bc(bj,J)if not aa then return bi(bj,J,"expected a type")end;if aa.typename=="function"and aa.maybe_method then aa.is_method=true end;local dC=aP.conststr or aP.tk;local dE=bB.fields;local dF=bB.field_order;if e0 then if not bB.meta_fields then bB.meta_fields={}bB.meta_field_order={}end;dE=bB.meta_fields;dF=bB.meta_field_order;if not dO[dC]then bi(bj,J-1,"not a valid metamethod: "..dC)end end;if bj.tokens[J].tk=="="and bj.tokens[J+1].tk=="macroexp"then if not(aa.typename=="function")then bi(bj,J+1,"macroexp must have a function type")else J,aa.macroexp=dP(bj,J+1,J+2)end end;dB(bj,dM,dC,aa,dE,dF)elseif bj.tokens[J].tk=="="then local bT=bj.tokens[J+1].tk;if bT=="record"or bT=="enum"then return bi(bj,J,"syntax error: this syntax is no longer valid; use '"..bT.." "..aP.tk.."'")elseif bT=="functiontype"then return bi(bj,J,"syntax error: this syntax is no longer valid; use 'type "..aP.tk.." = function('...")else return bi(bj,J,"syntax error: this syntax is no longer valid; use 'type "..aP.tk.." = '...")end else bi(bj,J,"syntax error: expected ':' for an attribute or '=' for a nested type")end end end;return J,true end;bh={["interface"]=bg,["record"]=bg,["enum"]=bf}local function e1(bj,J)local b4=bs(bj,J,"newtype")local bB;local bw=bj.tokens[J].tk;local bo=J;if bh[bw]then J,bB=bN(bj,J+1,bo,b4,bw)else J,bB=bc(bj,J)end;if not bB then return bi(bj,J,"expected a type")end;b4.newtype=bA(bj,bo,bB)if bB.typename=="nominal"then b4.newtype.is_alias=true elseif bB.typename=="generic"then local e2=bB.t;if e2.typename=="nominal"then b4.newtype.is_alias=true end end;return J,b4 end;local function e3(bj,J,e4)e4.exps=bs(bj,J,"expression_list")repeat J=J+1;local am;J,am=b7(bj,J)if not am then if#e4.exps==0 then e4.exps=nil end;return J end;table.insert(e4.exps,am)until bj.tokens[J].tk~=","return J,e4 end;local e5;do local function e6(b4)b4.is_lvalue=b4.kind=="variable"or b4.kind=="op"and(b4.op.op=="@index"or b4.op.op==".")return b4.is_lvalue end;local function e7(bj,J)local b4;J,b4=b7(bj,J)if not(b4 and e6(b4))then return bi(bj,J,"expected a variable")end;return J,b4 end;e5=function(bj,J)local e8;local bo=J;J,e8=b7(bj,J)if not e8 then return J end;if b3(e8)or e8.failstore then return J,e8 end;if not e6(e8)then return bi(bj,J,"syntax error")end;local e4=bs(bj,bo,"assignment")e4.vars=bs(bj,bo,"variable_list")e4.vars[1]=e8;if bj.tokens[J].tk==","then J=J+1;J=c6(bj,J,e4.vars,e7)if#e4.vars<2 then return bi(bj,J,"syntax error")end end;if bj.tokens[J].tk~="="then bm(bj,J,"=")return J end;J,e4=e3(bj,J,e4)return J,e4 end end;local function e9(bj,J,ea)local e4=bs(bj,J,ea)e4.vars=bs(bj,J,"variable_list")J=c6(bj,J,e4.vars,cX)if#e4.vars==0 then return bi(bj,J,"expected a local variable definition")end;J,e4.decltuple=b5(bj,J,"decltuple")if bj.tokens[J].tk=="="then local bT=bj.tokens[J+1].tk;local bw=bT;if bh[bw]then local eb=ea=="local_declaration"and"local"or"global"return bK(bj,J+1,"syntax error: this syntax is no longer valid; use '"..eb.." "..bT.." "..e4.vars[1].tk.."'",bP)elseif bT=="functiontype"then local eb=ea=="local_declaration"and"local"or"global"return bK(bj,J+1,"syntax error: this syntax is no longer valid; use '"..eb.." type "..e4.vars[1].tk.." = function('...",ce)end;J,e4=e3(bj,J,e4)end;return J,e4 end;local function ec(bj,J,e4)local bo=J;J,e4.value=b7(bj,J)if not e4.value then return J end;if e4.value.op and e4.value.op.op~="@funcall"and e4.value.op.op~="."then bi(bj,bo,"require() in type declarations cannot be part of larger expressions")return J end;if not b1(e4.value)then bi(bj,bo,"require() for type declarations must have a literal argument")return J end;return J,e4 end;local function ed(bj,J,e4)if bj.tokens[J].tk=="require"then return true,ec(bj,J,e4)elseif bj.tokens[J].tk=="pcall"then bi(bj,J,"pcall() cannot be used in type declarations")return true,J end;return false,J,e4 end;bd=function(bj,J,ea)local e4=bs(bj,J,ea)local ee;J,ee=bG(bj,J,"identifier")if not ee then return bi(bj,J,"expected a type name")end;local by;local ef=J;J,by=b6(bj,J)e4.var=ee;if ea=="global_type"and bj.tokens[J].tk~="="then return J,e4 end;J=bm(bj,J,"=")local bo=J;if bj.tokens[J].kind=="identifier"then local eg;eg,J,e4=ed(bj,J,e4)if eg then return J,e4 end end;J,e4.value=e1(bj,J)if not e4.value then return J end;local W=e4.value.newtype;if W.typename=="typedecl"then if by then local bB=W.def;if bB.typename=="generic"then bi(bj,ef,"cannot declare type arguments twice in type declaration")else W.def=bx(bj,bo,by,bB)end end;dJ(W.def,e4.var.tk)end;return J,e4 end;local function eh(bj,J,ea,bw)local e4=bs(bj,J,ea)local W=bs(bj,J,"newtype")e4.value=W;local bo=J;local bB;J=J+2;J,e4.var=bG(bj,J,"identifier")if not e4.var then return bi(bj,J,"expected a type name")end;J,bB=bN(bj,J,bo,W,bw)if not bB then return J end;dJ(bB,e4.var.tk)W.newtype=bA(bj,bo,bB)return J,e4 end;local function ei(bj,J)return bd(bj,J+1,"local_type")end;local function ej(bj,J)local bo=J;J=J+2;local b4=bs(bj,J,"local_macroexp")J,b4.name=d9(bj,J)J,b4.macrodef=dP(bj,bo,J)bl(b4,bj.tokens[J-1])return J,b4 end;local function ek(bj,J)local el=bj.tokens[J+1].tk;local bw=el;if el=="function"then return da(bj,J)elseif el=="type"and bj.tokens[J+2].kind=="identifier"then return bd(bj,J+2,"local_type")elseif el=="macroexp"and bj.tokens[J+2].kind=="identifier"then return ej(bj,J)elseif bh[bw]and bj.tokens[J+2].kind=="identifier"then return eh(bj,J,"local_type",bw)end;return e9(bj,J+1,"local_declaration")end;local function em(bj,J)local el=bj.tokens[J+1].tk;local bw=el;if el=="function"then return db(bj,J+1,"global")elseif el=="type"and bj.tokens[J+2].kind=="identifier"then return bd(bj,J+2,"global_type")elseif bh[bw]and bj.tokens[J+2].kind=="identifier"then return eh(bj,J,"global_type",bw)elseif bj.tokens[J+1].kind=="identifier"then return e9(bj,J+1,"global_declaration")end;return e5(bj,J)end;local function en(bj,J)return db(bj,J,"record")end;local function eo(bj,J)J=J+1;local ep=bs(bj,J,"pragma")if bj.tokens[J].kind~="pragma_identifier"then return bi(bj,J,"expected pragma name")end;ep.pkey=bj.tokens[J].tk;J=J+1;if bj.tokens[J].kind~="pragma_identifier"then return bi(bj,J,"expected pragma value")end;ep.pvalue=bj.tokens[J].tk;J=J+1;return J,ep end;local eq={["--#pragma"]=eo,["::"]=dx,["do"]=du,["if"]=dn,["for"]=ds,["goto"]=dw,["local"]=ek,["while"]=dp,["break"]=dv,["global"]=em,["repeat"]=dt,["return"]=dA,["function"]=en}local function er(bj,J)local a3=bj.tokens[J].tk;return bK(bj,J,("%s needs to be declared with 'local %s' or 'global %s'"):format(a3,a3,a3),bP)end;local es={["type"]=function(bj,J)return bK(bj,J,"types need to be declared with 'local type' or 'global type'",ei)end,["record"]=er,["enum"]=er}b9=function(bj,J,et)local b4=bs(bj,J,"statements")local ah;while true do while bj.tokens[J].kind==";"do J=J+1;if ah then ah.semicolon=true end end;if bj.tokens[J].kind=="$EOF$"then break end;local a3=bj.tokens[J].tk;if not et and dy[a3]then break end;local dd=eq[a3]if not dd then local bI=es[a3]if bI and bj.tokens[J+1].kind=="identifier"then dd=bI else dd=e5 end end;J,ah=dd(bj,J)if ah then table.insert(b4,ah)elseif J>1 then local aV=bj.tokens[J-1].y;while bj.tokens[J].kind~="$EOF$"and bj.tokens[J].y==aV do J=J+1 end end end;bl(b4,bj.tokens[J])return J,b4 end;function h.parse_program(M,V,L,eu)V=V or{}local bj={tokens=M,errs=V,filename=L or"",required_modules={},parse_lang=eu}local J=1;local ev;if bj.tokens[J].kind=="hashbang"then ev=bj.tokens[J].tk;J=J+1 end;local E,b4=b9(bj,J,true)if ev then b4.hashbang=ev end;aR(V)return b4,bj.required_modules end;function h.parse(I,L,eu)local M,V=h.lex(I,L)local b4,ew=h.parse_program(M,V,L,eu)return b4,V,ew end end;local function ex(aa,ey)local J=1;local dF,dE;if ey then dF,dE=aa.meta_field_order,aa.meta_fields else dF,dE=aa.field_order,aa.fields end;if not dE then return function()end end;return function()local u=dF[J]if not u then return nil end;J=J+1;return u,dE[u]end end;local ez=0;local eA=nil;local eB=1;local function eC(P,Q)return(tostring(P)or"?")..":"..(tostring(Q)or"?")end;local function eD(eE,P,Q,eF,...)if eA then if eA.y and eA.y>eB then io.stderr:write("\n")eB=eA.y end;io.stderr:write(("   "):rep(ez)..eA.mark.." "..eC(eA.y,eA.x).." "..eA.msg.."\n")io.stderr:flush()eA=nil;ez=ez+1 end;eA={mark=eE,y=P,x=Q,msg=eF:format(...)}end;local function eG(eE,eH,P,Q,eF,...)if eA then local a9=eA.msg;if eF then a9=eF:format(...)end;if P and P>eB then io.stderr:write("\n")eB=P end;io.stderr:write(("   "):rep(ez)..eH.." "..eC(P,Q).." "..a9 .."\n")io.stderr:flush()eA=nil else ez=ez-1;if eF then io.stderr:write(("   "):rep(ez)..eE.." "..eF:format(...).."\n")io.stderr:flush()end end end;local eI;local function eJ(ak,eK,eL)local eM={}for J,eN in ipairs(eK.types)do eM[J]=eI(ak,eN,eL)end;return eM end;local function eO(ak,eK,eL)local eM={}if eK.interface_list then for E,eN in ipairs(eK.interface_list)do table.insert(eM,eI(ak,eN,eL))end end;if eK.elements then table.insert(eM,eI(ak,eK.elements,eL))end;if eK.fields then for E,eN in ex(eK)do table.insert(eM,eI(ak,eN,eL))end end;if eK.meta_fields then for E,eN in ex(eK,"meta")do table.insert(eM,eI(ak,eN,eL))end end;return eM end;local eP={["typevar"]=false,["unresolved_typearg"]=false,["unresolvable_typearg"]=false,["self"]=false,["enum"]=false,["boolean"]=false,["string"]=false,["nil"]=false,["thread"]=false,["number"]=false,["integer"]=false,["circular_require"]=false,["boolean_context"]=false,["emptytable"]=false,["unresolved_emptytable_value"]=false,["any"]=false,["unknown"]=false,["invalid"]=false,["none"]=false,["*"]=false,["generic"]=function(ak,eK,eL)local eM={}for E,eN in ipairs(eK.typeargs)do table.insert(eM,eI(ak,eN,eL))end;table.insert(eM,eI(ak,eK.t,eL))return eM end,["tuple"]=function(ak,eK,eL)local eM={}for J,eN in ipairs(eK.tuple)do eM[J]=eI(ak,eN,eL)end;return eM end,["union"]=eJ,["tupletable"]=eJ,["poly"]=eJ,["map"]=function(ak,eK,eL)return{eI(ak,eK.keys,eL),eI(ak,eK.values,eL)}end,["record"]=eO,["interface"]=eO,["function"]=function(ak,eK,eL)local eM={}if eK.args then for E,eN in ipairs(eK.args.tuple)do table.insert(eM,eI(ak,eN,eL))end end;if eK.rets then for E,eN in ipairs(eK.rets.tuple)do table.insert(eM,eI(ak,eN,eL))end end;return eM end,["nominal"]=function(ak,eK,eL)local eM={}if eK.typevals then for E,eN in ipairs(eK.typevals)do table.insert(eM,eI(ak,eN,eL))end end;return eM end,["typearg"]=function(ak,eK,eL)return{eK.constraint and eI(ak,eK.constraint,eL)}end,["array"]=function(ak,eK,eL)return{eI(ak,eK.elements,eL)}end,["literal_table_item"]=function(ak,eK,eL)return{eI(ak,eK.ktype,eL),eI(ak,eK.vtype,eL)}end,["typedecl"]=function(ak,eK,eL)return{eI(ak,eK.def,eL)}end}eI=function(ak,eK,eL)local a2=eK.typename;if m then eD("---",eK.y,eK.x,"[%s] = %s",a2,aD(eK))end;local eQ=eL.cbs;local eR=eQ and eQ[a2]if eR then local eS=eR.before;if eS then eS(ak,eK)end end;local eM;local eT=eP[eK.typename]if not(type(eT)=="boolean")then eM=eT(ak,eK,eL)end;local eU;local eV=eR and eR.after;if eV then eU=eV(ak,eK,eM)end;local eW=eL.after;if eW then eU=eW(ak,eK,eM,eU)end;if m then eG("---","---",eK.y,eK.x)end;return eU end;local function eX(ak,eK,eY)if eK.typeargs then for E,eZ in ipairs(eK.typeargs)do eI(ak,eZ,eY)end end end;local function e_(u,ak,eK,eM,f0)local eQ=f0.cbs;if not eQ then return end;local f1=eQ[eK.kind]if not f1 then return end;local f2=f1[u]if not f2 then return end;f2(ak,eK,eM)end;local f3={["..."]=true,["nil"]=true,["cast"]=true,["goto"]=true,["break"]=true,["label"]=true,["number"]=true,["pragma"]=true,["string"]=true,["boolean"]=true,["integer"]=true,["variable"]=true,["error_node"]=true,["identifier"]=true,["type_identifier"]=true}local function f4(ak,f5,f0,eY)if not f5 then return end;local f6;local function f7(eK,eM)for J,eN in ipairs(eK)do eM[J]=f6(eN)end end;local function f8(eK,eM)eM[1]=f6(eK.vars)if eK.decltuple then eM[2]=eI(ak,eK.decltuple,eY)end;e_("before_exp",ak,eK,eM,f0)if eK.exps then eM[3]=f6(eK.exps)end end;local function f9(eK,eM)eX(ak,eK,eY)eM[1]=f6(eK.name)eM[2]=f6(eK.args)eM[3]=eI(ak,eK.rets,eY)e_("before_statements",ak,eK,eM,f0)eM[4]=f6(eK.body)end;local fa={["op"]=function(eK,eM)eM[1]=f6(eK.e1)local fb=eK.e1.op and eK.e1.op.prec or nil;if eK.op.op==":"and eK.e1.kind=="string"then fb=-999 end;eM[2]=fb;if eK.op.arity==2 then e_("before_e2",ak,eK,eM,f0)if eK.op.op=="is"or eK.op.op=="as"then eM[3]=eI(ak,eK.e2.casttype,eY)else eM[3]=f6(eK.e2)end;eM[4]=eK.e2.op and eK.e2.op.prec end end,["statements"]=f7,["argument_list"]=f7,["literal_table"]=f7,["variable_list"]=f7,["expression_list"]=f7,["literal_table_item"]=function(eK,eM)eM[1]=f6(eK.key)eM[2]=f6(eK.value)if eK.itemtype then eM[3]=eI(ak,eK.itemtype,eY)end end,["assignment"]=f8,["local_declaration"]=f8,["global_declaration"]=f8,["local_type"]=function(eK,eM)eM[1]=f6(eK.var)eM[2]=f6(eK.value)end,["global_type"]=function(eK,eM)eM[1]=f6(eK.var)if eK.value then eM[2]=f6(eK.value)end end,["if"]=function(eK,eM)for E,al in ipairs(eK.if_blocks)do table.insert(eM,f6(al))end end,["if_block"]=function(eK,eM)if eK.exp then eM[1]=f6(eK.exp)end;e_("before_statements",ak,eK,eM,f0)eM[2]=f6(eK.body)end,["while"]=function(eK,eM)eM[1]=f6(eK.exp)e_("before_statements",ak,eK,eM,f0)eM[2]=f6(eK.body)end,["repeat"]=function(eK,eM)eM[1]=f6(eK.body)eM[2]=f6(eK.exp)end,["macroexp"]=function(eK,eM)eX(ak,eK,eY)eM[1]=f6(eK.args)eM[2]=eI(ak,eK.rets,eY)e_("before_exp",ak,eK,eM,f0)eM[3]=f6(eK.exp)end,["function"]=function(eK,eM)eX(ak,eK,eY)eM[1]=f6(eK.args)eM[2]=eI(ak,eK.rets,eY)e_("before_statements",ak,eK,eM,f0)eM[3]=f6(eK.body)end,["local_function"]=f9,["global_function"]=f9,["record_function"]=function(eK,eM)eX(ak,eK,eY)eM[1]=f6(eK.fn_owner)eM[2]=f6(eK.name)e_("before_arguments",ak,eK,eM,f0)eM[3]=f6(eK.args)eM[4]=eI(ak,eK.rets,eY)e_("before_statements",ak,eK,eM,f0)eM[5]=f6(eK.body)end,["local_macroexp"]=function(eK,eM)eM[1]=f6(eK.name)eM[2]=f6(eK.macrodef.args)eM[3]=eI(ak,eK.macrodef.rets,eY)e_("before_exp",ak,eK,eM,f0)eM[4]=f6(eK.macrodef.exp)end,["forin"]=function(eK,eM)eM[1]=f6(eK.vars)eM[2]=f6(eK.exps)e_("before_statements",ak,eK,eM,f0)eM[3]=f6(eK.body)end,["fornum"]=function(eK,eM)eM[1]=f6(eK.var)eM[2]=f6(eK.from)eM[3]=f6(eK.to)eM[4]=eK.step and f6(eK.step)e_("before_statements",ak,eK,eM,f0)eM[5]=f6(eK.body)end,["return"]=function(eK,eM)eM[1]=f6(eK.exps)end,["do"]=function(eK,eM)eM[1]=f6(eK.body)end,["paren"]=function(eK,eM)eM[1]=f6(eK.e1)end,["newtype"]=function(eK,eM)eM[1]=eI(ak,eK.newtype,eY)end,["argument"]=function(eK,eM)if eK.argtype then eM[1]=eI(ak,eK.argtype,eY)end end}if not f0.allow_missing_cbs and not f0.cbs then error("missing cbs in visit_node")end;local eW=f0.after;f6=function(eK)local eM={}local a2=assert(eK.kind)local fc;local eQ=f0.cbs;local eR=eQ and eQ[a2]if eR then if eR.before then eR.before(ak,eK)end end;if m then if eK.y>o then error("Halting execution at input line "..eK.y)end;fc=a2=="op"and"op "..eK.op.op or a2=="identifier"and"identifier "..eK.tk or a2;eD("{{{",eK.y,eK.x,"[%s]",fc)end;local dd=fa[a2]if dd then dd(eK,eM)else assert(f3[a2])end;local eU;local eV=eR and eR.after;if eV then eU=eV(ak,eK,eM)end;if eW then eU=eW(ak,eK,eM,eU)end;if m then local aL=eK.debug_type and" = "..aD(eK.debug_type)or""eG("}}}","***",eK.y,eK.x,"[%s]%s",fc,aL)end;return eU end;return f6(f5)end;local fd={[1]={["-"]=true,["~"]=true,["#"]=true},[2]={["."]=true,[":"]=true}}local fe={[1]={["not"]=true},[2]={["or"]=true,["and"]=true,["<"]=true,[">"]=true,["<="]=true,[">="]=true,["~="]=true,["=="]=true,["|"]=true,["~"]=true,["&"]=true,["<<"]=true,[">>"]=true,[".."]=true,["+"]=true,["-"]=true,["*"]=true,["/"]=true,["//"]=true,["%"]=true,["^"]=true}}local ff={preserve_indent=true,preserve_newlines=true,preserve_hashbang=false}local fg={preserve_indent=false,preserve_newlines=true,preserve_hashbang=false}local fh={["function"]="function",["enum"]="string",["boolean"]="boolean",["string"]="string",["nil"]="nil",["number"]="number",["integer"]="number",["thread"]="thread"}function h.generate(eK,fi,d0)local aW;local fj=0;d0=d0 or ff;local fk={}local function fl(E,b4)local eN=b4.body or b4[1]if not eN then return end;if eN.y~=b4.y then if fj==0 and#fk>0 then fj=fk[#fk]+1 else fj=fj+1 end else table.insert(fk,fj)fj=0 end end;local function fm(b4,eN)if eN.y~=b4.y then fj=fj-1 else fj=table.remove(fk)end end;if not d0.preserve_indent then fl=nil;fm=function()end end;local function fn(fo,ak)table.insert(fo,ak)if string.find(ak,"\n",1,true)then for fp in ak:gmatch("\n")do fo.h=fo.h+1 end end end;local function fq(fo,eN,fr,fs)if#eN==0 then return end;if eN.y~=-1 and eN.y<fo.y then fo.y=eN.y end;if eN.y>fo.y+fo.h and d0.preserve_newlines then local ft=eN.y-(fo.y+fo.h)fo.h=fo.h+ft;table.insert(fo,("\n"):rep(ft))else if fr then if fr~=""then table.insert(fo,fr)end;fs=nil end end;if fs and d0.preserve_indent then table.insert(fo,("   "):rep(fs))end;table.insert(fo,eN)fo.h=fo.h+eN.h end;local function fu(fo)for J,ak in ipairs(fo)do if type(ak)=="table"then fo[J]=fu(ak)end end;return table.concat(fo)end;local function fv(aL)local fo={"{"}local J=0;for fw,fx in ex(aL)do if fx.typename=="typedecl"then local bB=fx.def;if bB.typename=="generic"then bB=bB.t end;if bB.typename=="record"then if J>0 then table.insert(fo,",")end;J=J+1;table.insert(fo," ")table.insert(fo,fw)table.insert(fo," = ")table.insert(fo,fv(bB))end end end;if J>0 then table.insert(fo," ")end;table.insert(fo,"}")return table.concat(fo)end;local f0={}local fy={["const"]=" <const>",["close"]=" <close>",["total"]=" <const>"}local function fz(E,b4,fA)local fo={y=b4.y,h=0}fn(fo,b4.tk)return fo end;local fB={after=fz}f0.cbs={["statements"]={after=function(E,b4,fC)local fo;if d0.preserve_hashbang and b4.hashbang then fo={y=1,h=0}table.insert(fo,b4.hashbang)else fo={y=b4.y,h=0}end;local fr;for J,eN in ipairs(fC)do fq(fo,eN,fr,fj)if b4[J].semicolon then table.insert(fo,";")fr=" "else fr="; "end end;return fo end},["local_declaration"]={after=function(E,b4,fC)local fo={y=b4.y,h=0}table.insert(fo,"local ")for J,ee in ipairs(b4.vars)do if J>1 then fn(fo,", ")end;fn(fo,ee.tk)if ee.attribute then if fi~="5.4"and ee.attribute=="close"then aW="attempt to emit a <close> attribute for a non 5.4 target"end;if fi=="5.4"then fn(fo,fy[ee.attribute])end end end;if fC[3]then table.insert(fo," =")fq(fo,fC[3]," ")end;return fo end},["local_type"]={after=function(E,b4,fC)local fo={y=b4.y,h=0}if not b4.var.elide_type then table.insert(fo,"local")fq(fo,fC[1]," ")table.insert(fo," =")fq(fo,fC[2]," ")end;return fo end},["global_type"]={after=function(E,b4,fC)local fo={y=b4.y,h=0}if fC[2]then fq(fo,fC[1])table.insert(fo," =")fq(fo,fC[2]," ")end;return fo end},["global_declaration"]={after=function(E,b4,fC)local fo={y=b4.y,h=0}if fC[3]then fq(fo,fC[1])table.insert(fo," =")fq(fo,fC[3]," ")end;return fo end},["assignment"]={after=function(E,b4,fC)local fo={y=b4.y,h=0}fq(fo,fC[1])table.insert(fo," =")fq(fo,fC[3]," ")return fo end},["if"]={after=function(E,b4,fC)local fo={y=b4.y,h=0}for J,eN in ipairs(fC)do fq(fo,eN,J>1 and" ",eN.y~=b4.y and fj)end;fq(fo,{y=b4.yend,h=0,[1]="end"}," ",fj)return fo end},["if_block"]={before=fl,after=function(E,b4,fC)local fo={y=b4.y,h=0}if b4.if_block_n==1 then table.insert(fo,"if")elseif not b4.exp then table.insert(fo,"else")else table.insert(fo,"elseif")end;if b4.exp then fq(fo,fC[1]," ")table.insert(fo," then")end;fq(fo,fC[2]," ")fm(b4,b4.body)return fo end},["while"]={before=fl,after=function(E,b4,fC)local fo={y=b4.y,h=0}table.insert(fo,"while")fq(fo,fC[1]," ")table.insert(fo," do")fq(fo,fC[2]," ")fm(b4,b4.body)fq(fo,{y=b4.yend,h=0,[1]="end"}," ",fj)return fo end},["repeat"]={before=fl,after=function(E,b4,fC)local fo={y=b4.y,h=0}table.insert(fo,"repeat")fq(fo,fC[1]," ")fm(b4,b4.body)fq(fo,{y=b4.yend,h=0,[1]="until "}," ",fj)fq(fo,fC[2])return fo end},["do"]={before=fl,after=function(E,b4,fC)local fo={y=b4.y,h=0}table.insert(fo,"do")fq(fo,fC[1]," ")fm(b4,b4.body)fq(fo,{y=b4.yend,h=0,[1]="end"}," ",fj)return fo end},["forin"]={before=fl,after=function(E,b4,fC)local fo={y=b4.y,h=0}table.insert(fo,"for")fq(fo,fC[1]," ")table.insert(fo," in")fq(fo,fC[2]," ")table.insert(fo," do")fq(fo,fC[3]," ")fm(b4,b4.body)fq(fo,{y=b4.yend,h=0,[1]="end"}," ",fj)return fo end},["fornum"]={before=fl,after=function(E,b4,fC)local fo={y=b4.y,h=0}table.insert(fo,"for")fq(fo,fC[1]," ")table.insert(fo," =")fq(fo,fC[2]," ")table.insert(fo,",")fq(fo,fC[3]," ")if fC[4]then table.insert(fo,",")fq(fo,fC[4]," ")end;table.insert(fo," do")fq(fo,fC[5]," ")fm(b4,b4.body)fq(fo,{y=b4.yend,h=0,[1]="end"}," ",fj)return fo end},["return"]={after=function(E,b4,fC)local fo={y=b4.y,h=0}table.insert(fo,"return")if#fC[1]>0 then fq(fo,fC[1]," ")end;return fo end},["break"]={after=function(E,b4,fA)local fo={y=b4.y,h=0}table.insert(fo,"break")return fo end},["variable_list"]={after=function(E,b4,fC)local fo={y=b4.y,h=0}local fr;for J,eN in ipairs(fC)do if J>1 then table.insert(fo,",")fr=" "end;fq(fo,eN,fr,eN.y~=b4.y and fj)end;return fo end},["literal_table"]={before=fl,after=function(E,b4,fC)local fo={y=b4.y,h=0}if#fC==0 then table.insert(fo,"{}")return fo end;table.insert(fo,"{")local b2=#fC;for J,eN in ipairs(fC)do fq(fo,eN," ",eN.y~=b4.y and fj)if J<b2 or b4.yend~=b4.y then table.insert(fo,",")end end;fm(b4,b4[1])fq(fo,{y=b4.yend,h=0,[1]="}"}," ",fj)return fo end},["literal_table_item"]={after=function(E,b4,fC)local fo={y=b4.y,h=0}if b4.key_parsed~="implicit"then if b4.key_parsed=="short"then fC[1][1]=fC[1][1]:sub(2,-2)fq(fo,fC[1])table.insert(fo," = ")else table.insert(fo,"[")if b4.key_parsed=="long"and b4.key.is_longstring then table.insert(fC[1],1," ")table.insert(fC[1]," ")end;fq(fo,fC[1])table.insert(fo,"] = ")end end;fq(fo,fC[2])return fo end},["local_macroexp"]={before=fl,after=function(E,b4,fA)return{y=b4.y,h=0}end},["local_function"]={before=fl,after=function(E,b4,fC)local fo={y=b4.y,h=0}table.insert(fo,"local function")fq(fo,fC[1]," ")table.insert(fo,"(")fq(fo,fC[2])table.insert(fo,")")fq(fo,fC[4]," ")fm(b4,b4.body)fq(fo,{y=b4.yend,h=0,[1]="end"}," ",fj)return fo end},["global_function"]={before=fl,after=function(E,b4,fC)local fo={y=b4.y,h=0}table.insert(fo,"function")fq(fo,fC[1]," ")table.insert(fo,"(")fq(fo,fC[2])table.insert(fo,")")fq(fo,fC[4]," ")fm(b4,b4.body)fq(fo,{y=b4.yend,h=0,[1]="end"}," ",fj)return fo end},["record_function"]={before=fl,after=function(E,b4,fC)local fo={y=b4.y,h=0}table.insert(fo,"function")fq(fo,fC[1]," ")table.insert(fo,b4.is_method and":"or".")fq(fo,fC[2])table.insert(fo,"(")if b4.is_method then table.remove(fC[3],1)if fC[3][1]==","then table.remove(fC[3],1)if fC[3][1]==" "then table.remove(fC[3],1)end end end;fq(fo,fC[3])table.insert(fo,")")fq(fo,fC[5]," ")fm(b4,b4.body)fq(fo,{y=b4.yend,h=0,[1]="end"}," ",fj)return fo end},["function"]={before=fl,after=function(E,b4,fC)local fo={y=b4.y,h=0}table.insert(fo,"function(")fq(fo,fC[1])table.insert(fo,")")fq(fo,fC[3]," ")fm(b4,b4.body)fq(fo,{y=b4.yend,h=0,[1]="end"}," ",fj)return fo end},["cast"]={},["paren"]={after=function(E,b4,fC)local fo={y=b4.y,h=0}table.insert(fo,"(")fq(fo,fC[1],"",fj)table.insert(fo,")")return fo end},["op"]={after=function(E,b4,fC)local fo={y=b4.y,h=0}if b4.op.op=="@funcall"then fq(fo,fC[1],"",fj)table.insert(fo,"(")fq(fo,fC[3],"",fj)table.insert(fo,")")elseif b4.op.op=="@index"then fq(fo,fC[1],"",fj)table.insert(fo,"[")if b4.e2.is_longstring then table.insert(fC[3],1," ")table.insert(fC[3]," ")end;fq(fo,fC[3],"",fj)table.insert(fo,"]")elseif b4.op.op=="as"then fq(fo,fC[1],"",fj)elseif b4.op.op=="is"then if b4.e2.casttype.typename=="integer"then table.insert(fo,"math.type(")fq(fo,fC[1],"",fj)table.insert(fo,") == \"integer\"")elseif b4.e2.casttype.typename=="nil"then fq(fo,fC[1],"",fj)table.insert(fo," == nil")else table.insert(fo,"type(")fq(fo,fC[1],"",fj)table.insert(fo,") == \"")fq(fo,fC[3],"",fj)table.insert(fo,"\"")end elseif fe[b4.op.arity][b4.op.op]or fd[b4.op.arity][b4.op.op]then local fr=fe[b4.op.arity][b4.op.op]and" "or""if fC[2]and b4.op.prec>tonumber(fC[2])then table.insert(fC[1],1,"(")table.insert(fC[1],")")end;if b4.op.arity==1 then table.insert(fo,b4.op.op)fq(fo,fC[1],fr,fj)elseif b4.op.arity==2 then fq(fo,fC[1],"",fj)if fr==" "then table.insert(fo," ")end;table.insert(fo,b4.op.op)if fC[4]and b4.op.prec>tonumber(fC[4])then table.insert(fC[3],1,"(")table.insert(fC[3],")")end;fq(fo,fC[3],fr,fj)end else error("unknown node op "..b4.op.op)end;return fo end},["newtype"]={after=function(E,b4,fA)local fo={y=b4.y,h=0}local W=b4.newtype;if W.typename=="typedecl"then local bB=W.def;if bB.fields then table.insert(fo,fv(bB))elseif bB.typename=="nominal"then table.insert(fo,table.concat(bB.names,"."))else table.insert(fo,"{}")end end;return fo end},["goto"]={after=function(E,b4,fA)local fo={y=b4.y,h=0}table.insert(fo,"goto ")table.insert(fo,b4.label)return fo end},["label"]={after=function(E,b4,fA)local fo={y=b4.y,h=0}table.insert(fo,"::")table.insert(fo,b4.label)table.insert(fo,"::")return fo end},["string"]={after=function(E,b4,fC)if b4.tk:sub(1,1)=="["or fi~="5.1"or not b4.tk:find("\\",1,true)then return fz(nil,b4,fC)end;local fo={y=b4.y,h=0}local fD=b4.tk;for E in fD:gmatch("\n")do fo.h=fo.h+1 end;fD=fD:gsub("()\\z(%s*)",function(fE,fF)local fG=fE-1;if fD:sub(fG,fG)=="\\"then return"\\z"..fF end;for E in fF:gmatch("\n")do fo.h=fo.h-1 end;return""end)fD=fD:gsub("()\\x(..)",function(fE,fH)local fG=fE-1;if fD:sub(fG,fG)=="\\"then return"\\x"..fH end;local fI=tonumber(fH,16)return fI and string.format("\\%03d",fI)or"\\x"..fH end)fD=fD:gsub("()\\u{(.-)}",function(fE,fJ)local fG=fE-1;if fD:sub(fG,fG)=="\\"then return"\\u{"..fJ.."}"end;local fK=tonumber(fJ,16)if not fK then return"\\000"end;local fL=utf8.char(fK)return fL:gsub(".",function(y)return("\\%03d"):format(string.byte(y))end)end)fo[1]=fD;return fo end},["pragma"]={},["variable"]=fB,["identifier"]=fB,["number"]=fB,["integer"]=fB,["nil"]=fB,["boolean"]=fB,["..."]=fB,["argument"]=fB,["type_identifier"]=fB}local eY={}eY.cbs={}local fM={after=function(E,aL,fA)local fo={y=aL.y or-1,h=0}local cx=aL.typename=="nominal"and aL.resolved or aL;local fN=fh[cx.typename]or"table"if cx.fields and cx.is_userdata then fN="userdata"end;table.insert(fo,fN)return fo end}eY.cbs["string"]=fM;eY.cbs["typedecl"]=fM;eY.cbs["typevar"]=fM;eY.cbs["typearg"]=fM;eY.cbs["function"]=fM;eY.cbs["thread"]=fM;eY.cbs["array"]=fM;eY.cbs["map"]=fM;eY.cbs["tupletable"]=fM;eY.cbs["record"]=fM;eY.cbs["enum"]=fM;eY.cbs["boolean"]=fM;eY.cbs["nil"]=fM;eY.cbs["number"]=fM;eY.cbs["integer"]=fM;eY.cbs["union"]=fM;eY.cbs["nominal"]=fM;eY.cbs["emptytable"]=fM;eY.cbs["literal_table_item"]=fM;eY.cbs["unresolved_emptytable_value"]=fM;eY.cbs["tuple"]=fM;eY.cbs["poly"]=fM;eY.cbs["any"]=fM;eY.cbs["unknown"]=fM;eY.cbs["invalid"]=fM;eY.cbs["none"]=fM;f0.cbs["expression_list"]=f0.cbs["variable_list"]f0.cbs["argument_list"]=f0.cbs["variable_list"]local fo=f4(nil,eK,f0,eY)if aW then return nil,aW end;local fO;if d0.preserve_newlines then fO={y=1,h=0}fq(fO,fo)else fO=fo end;return fu(fO):gsub(" *\n","\n")end;local fP={["typevar"]=h.typecodes.TYPE_VARIABLE,["typearg"]=h.typecodes.TYPE_VARIABLE,["unresolved_typearg"]=h.typecodes.TYPE_VARIABLE,["unresolvable_typearg"]=h.typecodes.TYPE_VARIABLE,["function"]=h.typecodes.FUNCTION,["array"]=h.typecodes.ARRAY,["map"]=h.typecodes.MAP,["tupletable"]=h.typecodes.TUPLE,["interface"]=h.typecodes.INTERFACE,["self"]=h.typecodes.SELF,["record"]=h.typecodes.RECORD,["enum"]=h.typecodes.ENUM,["boolean"]=h.typecodes.BOOLEAN,["string"]=h.typecodes.STRING,["nil"]=h.typecodes.NIL,["thread"]=h.typecodes.THREAD,["number"]=h.typecodes.NUMBER,["integer"]=h.typecodes.INTEGER,["union"]=h.typecodes.UNION,["nominal"]=h.typecodes.NOMINAL,["circular_require"]=h.typecodes.NOMINAL,["boolean_context"]=h.typecodes.BOOLEAN,["emptytable"]=h.typecodes.EMPTY_TABLE,["unresolved_emptytable_value"]=h.typecodes.EMPTY_TABLE,["poly"]=h.typecodes.POLY,["any"]=h.typecodes.ANY,["unknown"]=h.typecodes.UNKNOWN,["invalid"]=h.typecodes.INVALID,["none"]=h.typecodes.UNKNOWN,["tuple"]=h.typecodes.UNKNOWN,["literal_table_item"]=h.typecodes.UNKNOWN,["typedecl"]=h.typecodes.UNKNOWN,["generic"]=h.typecodes.UNKNOWN,["*"]=h.typecodes.UNKNOWN}local fQ={["none"]=true,["tuple"]=true,["literal_table_item"]=true}local function fR(c)local fS={}for ac,E in pairs(c)do table.insert(fS,ac)end;table.sort(fS)return fS end;local function fT(Q)local fU=Q;fU[0]=false;return Q end;function h.new_type_reporter()local self=setmetatable({next_num=1,typeid_to_num={},typename_to_num={},tr={by_pos={},types={},symbols_by_file={},globals={}}},{__index=i})local de={}for u,E in pairs(b0)do table.insert(de,u)end;table.sort(de)for E,u in ipairs(de)do local Z={t=assert(fP[u]),str=u}local b2=self.next_num;self.typename_to_num[u]=b2;self.tr.types[b2]=Z;self.next_num=self.next_num+1 end;return self end;function i:store_function(Z,fV)local cP={}for E,d2 in ipairs(fV.args.tuple)do table.insert(cP,fT({self:get_typenum(d2),nil}))end;Z.args=fT(cP)local fW={}for E,d2 in ipairs(fV.rets.tuple)do table.insert(fW,fT({self:get_typenum(d2),nil}))end;Z.rets=fT(fW)Z.vararg=not not fV.args.is_va;Z.varret=not not fV.rets.is_va end;function i:get_typenum(aa)local b2=self.typename_to_num[aa.typename]if b2 then return b2 end;assert(aa.typeid)b2=self.typeid_to_num[aa.typeid]if b2 then return b2 end;local fX=self.tr;b2=self.next_num;local fV=aa;if fV.typename=="tuple"and#fV.tuple==1 then fV=fV.tuple[1]end;if fV.typename=="typedecl"then return self:get_typenum(fV.def)end;if fV.typename=="generic"then fV=fV.t end;local Z={t=assert(fP[fV.typename]),str=aD(aa,true),file=aa.f,y=aa.y,x=aa.x}fX.types[b2]=Z;self.typeid_to_num[aa.typeid]=b2;self.next_num=self.next_num+1;if aa.typename=="nominal"then if aa.found then Z.ref=self:get_typenum(aa.found)end;if aa.resolved then fV=aa end end;assert(not(fV.typename=="typedecl"))if fV.fields then local cx={}for E,ac in ipairs(fV.field_order)do local aP=fV.fields[ac]cx[ac]=self:get_typenum(aP)end;Z.fields=cx end;if fV.elements then Z.elements=self:get_typenum(fV.elements)end;if fV.typename=="map"then Z.keys=self:get_typenum(fV.keys)Z.values=self:get_typenum(fV.values)elseif fV.typename=="enum"then Z.enums=fT(fR(fV.enumset))elseif fV.typename=="function"then self:store_function(Z,fV)elseif fV.types then local fY={}for E,fZ in ipairs(fV.types)do table.insert(fY,self:get_typenum(fZ))end;Z.types=fT(fY)end;return b2 end;function i:add_field(f_,fw,fx)local b2=self:get_typenum(f_)local Z=self.tr.types[b2]assert(Z.fields)Z.fields[fw]=self:get_typenum(fx)end;function i:set_ref(g0,g1)local b2=self:get_typenum(g0)local Z=self.tr.types[b2]Z.ref=self:get_typenum(g1)end;function i:get_collector(L)local g2={filename=L,symbol_list={}}local g3={}self.tr.by_pos[L]=g3;local g4=g2.symbol_list;local g5=0;g2.store_type=function(P,Q,aL)if not aL or fQ[aL.typename]then return end;local g6=g3[P]if not g6 then g6={}g3[P]=g6 end;g6[Q]=self:get_typenum(aL)end;g2.reserve_symbol_list_slot=function(b4)g5=g5+1;b4.symbol_list_slot=g5 end;g2.add_to_symbol_list=function(b4,u,aa)if not b4 then return end;local g7;if b4.symbol_list_slot then g7=b4.symbol_list_slot else g5=g5+1;g7=g5 end;g4[g7]={y=b4.y,x=b4.x,name=u,typ=aa}end;g2.begin_symbol_list_scope=function(b4)g5=g5+1;g4[g5]={y=b4.y,x=b4.x,name="@{"}end;g2.rollback_symbol_list_scope=function()while g4[g5].name~="@{"do g4[g5]=nil;g5=g5-1 end end;g2.end_symbol_list_scope=function(b4)if g4[g5].name=="@{"then g4[g5]=nil;g5=g5-1 else g5=g5+1;g4[g5]={y=assert(b4.yend),x=assert(b4.xend),name="@}"}end end;return g2 end;function i:store_result(g2,g8)local fX=self.tr;local L=g2.filename;local g4=g2.symbol_list;fX.by_pos[L][0]=nil;do local b2=0;local b=0;local g9,ga={},{}local gb=0;for J,ak in ipairs(g4)do if ak.typ then b2=b2+1 elseif ak.name=="@{"then gb=gb+1;g9[gb],ga[gb]=b2,b;b2,b=0,J else if b2==0 then g4[b].skip=true;ak.skip=true end;b2,b=g9[gb],ga[gb]gb=gb-1 end end end;local gc=fT({})fX.symbols_by_file[L]=gc;do local gd={}local gb=0;local J=0;for E,ak in ipairs(g4)do if not ak.skip then J=J+1;local ge;if ak.typ then ge=self:get_typenum(ak.typ)elseif ak.name=="@{"then gb=gb+1;gd[gb]=J;ge=-1 else local gf=gd[gb]gb=gb-1;gc[gf][4]=J;ge=gf-1 end;local gg=fT({ak.y,ak.x,ak.name,ge})table.insert(gc,gg)end end end;local gh=fR(g8)for E,u in ipairs(gh)do if u:sub(1,1)~="@"then local ee=g8[u]fX.globals[u]=self:get_typenum(ee.t)end end;if not fX.symbols then fX.symbols=fX.symbols_by_file[L]end end;function i:get_report()return self.tr end;function h.symbols_in_scope(fX,P,Q,L)local function gi(gc,gj,gk)local function gl(aX,aY)return aX[1]<aY[1]or aX[1]==aY[1]and aX[2]<=aY[2]end;return af(gc,{gj,gk},gl)or 0 end;local eU={}local gc=fX.symbols_by_file[L]if not gc then return eU end;local b2=gi(gc,P,Q)while b2>=1 do local ak=gc[b2]if ak[3]=="@{"then b2=b2-1 elseif ak[3]=="@}"then b2=ak[4]else eU[ak[3]]=ak[4]b2=b2-1 end end;return eU end;function g.new(L)local self={errors={},warnings={},unknown_dots={},filename=L}return setmetatable(self,{__index=g})end;local function gm(a9,cL,gn,go)if cL then local gp,gq,gr;if cL.typename=="invalid"then return nil end;gp=aD(cL)if gn then if gn.typename=="invalid"then return nil end;gq=aD(gn)end;if go then if go.typename=="invalid"then return nil end;gr=aD(go)end;a9=a9:format(gp,gq,gr)return{msg=a9,x=cL.x,y=cL.y,filename=cL.f}end;return{msg=a9}end;local function gs(aG,a9)return{msg=a9,x=assert(aG.x),y=assert(aG.y),filename=assert(aG.f)}end;local function gt(self,P,Q,ct,aW)aW.y=assert(P)aW.x=assert(Q)aW.filename=assert(ct)if m then io.stderr:write("ERROR:"..aW.y..":"..aW.x..": "..aW.msg.."\n")end;table.insert(self.errors,aW)end;function g:add(aG,a9,...)local al=gm(a9,...)if al then gt(self,aG.y,aG.x,aG.f,al)end end;local gu={["local_declaration"]="in local declaration",["global_declaration"]="in global declaration",["assignment"]="in assignment",["literal_table_item"]="in table item"}function g:get_context(gv,u)if not gv then return""end;local gw=gv.kind~=nil and gv.expected_context;local gx=type(gv)=="string"and gv or gv.kind~=nil and gu[gw and gw.kind or gv.kind]return(gx and gx..": "or"")..(gw and gw.name and gw.name..": "or"")..(u and u..": "or"")end;function g:add_in_context(aG,gv,a9,...)local gy=self:get_context(gv)a9=gy..a9;local al=gm(a9,...)if al then gt(self,aG.y,aG.x,aG.f,al)end end;function g:collect(V)for E,al in ipairs(V)do gt(self,al.y,al.x,al.filename,al)end end;function g:add_warning(gz,aG,eF,...)assert(aG.y)table.insert(self.warnings,{y=aG.y,x=aG.x,msg=eF:format(...),filename=assert(aG.f),tag=gz})end;function g:invalid_at(aG,a9,...)self:add(aG,a9,...)return aF(aG,"invalid",{})end;function g:add_unknown(b4,u)self:add_warning("unknown",b4,"unknown variable: %s",u)end;function g:redeclaration_warning(gA,gB,gC,gD)if gB:sub(1,1)=="_"then return end;local gE=gC.." shadows previous declaration of '%s'"if gD and gD.declared_at then self:add_warning("redeclaration",gA,gE.." (originally declared at %d:%d)",gB,gD.declared_at.y,gD.declared_at.x)else self:add_warning("redeclaration",gA,gE,gB)end end;local function gF(u,ee)local gy=u:sub(1,1)return not ee.declared_at or ee.is_specialized=="narrow"or gy=="_"or gy=="@"end;local function gG(ee)local aa=ee.t;return ee.is_func_arg and"argument"or aa.typename=="function"and"function"or aa.typename=="typedecl"and"type"or"variable"end;function g:unused_warning(u,ee)if gF(u,ee)then return end;self:add_warning("unused",ee.declared_at,"unused %s %s: %s",gG(ee),u,aD(ee.t))end;function g:add_prefixing(aG,gH,gy,gI)if not gH then return end;for E,aW in ipairs(gH)do aW.msg=gy..aW.msg;if aG and(aW.filename~=aG.f or not aW.y or(aG.y>aW.y or aG.y==aW.y and aG.x>aW.x))then aW.y=aG.y;aW.x=aG.x;aW.filename=aG.f end;if gI then table.insert(gI,aW)else gt(self,aW.y,aW.x,aW.filename,aW)end end end;local function gJ(bB,b4)if bB.typename=="record"then return true elseif bB.typename=="generic"then return gJ(bB.t)elseif b4 and b1(b4)then return nil,"module type is abstract: "..tostring(bB)elseif bB.typename=="interface"then return nil,"interfaces are abstract; consider using a concrete record"end;return nil,"cannot use a type definition as a concrete value"end;local function gK(aa,b4)if aa.typename=="function"and aa.macroexp then return nil,"macroexps are abstract; consider using a concrete function"elseif aa.typename=="generic"then return gK(aa.t,b4)elseif aa.typename=="typedecl"then return gJ(aa.def,b4)end;return true end;local function gL(ee)return ee.has_been_read_from or ee.has_been_written_to end;local function gM(eb,gN)local gO=eb.vars;if not next(gO)then return end;local gP;for u,ee in pairs(gO)do local aa=ee.t;if not gF(u,ee)then if ee.has_been_written_to and not ee.has_been_read_from then gP=gP or{}table.insert(gP,{y=ee.declared_at.y,x=ee.declared_at.x,name=u,var=ee,kind="written but not read"})end end;if ee.declared_at and not gL(ee)then if ee.used_as_type then ee.declared_at.elide_type=true else if aa.typename=="typedecl"and not gN then ee.declared_at.elide_type=true end;gP=gP or{}table.insert(gP,{y=ee.declared_at.y,x=ee.declared_at.x,name=u,var=ee,kind="unused"})end elseif gL(ee)and aa.typename=="typedecl"and ee.aliasing then ee.aliasing.has_been_written_to=ee.has_been_written_to;ee.aliasing.has_been_read_from=ee.has_been_read_from;if gK(aa)then ee.aliasing.declared_at.elide_type=false end end end;if gP then table.sort(gP,function(aX,aY)return aX.y<aY.y or aX.y==aY.y and aX.x<aY.x end)end;return gP end;function g:check_var_usage(eb,gN)local gP=gM(eb,gN)if gP then for E,cj in ipairs(gP)do if cj.kind=="unused"then self:unused_warning(cj.name,cj.var)elseif cj.kind=="written but not read"then self:add_warning("unread",cj.var.declared_at,"%s %s (of type %s) is never read",gG(cj.var),cj.name,aD(cj.var.t))end end end;if eb.labels then for u,b4 in pairs(eb.labels)do if not b4.used_label then self:add_warning("unused",b4,"unused label ::%s::",u)end end end end;function g:add_unknown_dot(b4,u)if not self.unknown_dots[u]then self.unknown_dots[u]=true;self:add_unknown(b4,u)end end;function g:fail_unresolved_labels(eb)if eb.pending_labels then for u,gQ in pairs(eb.pending_labels)do for E,b4 in ipairs(gQ)do self:add(b4,"no visible label '"..u.."' for goto")end end end end;function g:fail_unresolved_nominals(eb,gR)if gR and eb.pending_nominals then for u,bD in pairs(eb.pending_nominals)do if not gR.pending_global_types[u]and u~="metatable"then for E,aL in ipairs(bD)do assert(aL.x)assert(aL.y)self:add(aL,"unknown type %s",aL)end end end end end;function g:check_redeclared_key(aG,gv,gS,cM)if cM~=nil then local ak=gS[cM]if ak then self:add_in_context(aG,gv,"redeclared key "..tostring(cM).." (previously declared at "..self.filename..":"..ak.y..":"..ak.x..")")else gS[cM]=aG end end end;local gT={["number"]={["number"]="number",["integer"]="number"},["integer"]={["integer"]="integer",["number"]="number"}}local gU={["number"]={["number"]="number",["integer"]="number"},["integer"]={["integer"]="number",["number"]="number"}}local gV={["number"]={["number"]="integer",["integer"]="integer"},["integer"]={["integer"]="integer",["number"]="integer"}}local gW={["number"]={["integer"]="boolean",["number"]="boolean"},["integer"]={["number"]="boolean",["integer"]="boolean"},["string"]={["string"]="boolean"},["boolean"]={["boolean"]="boolean"}}local gX={["number"]={["number"]="boolean",["integer"]="boolean",["nil"]="boolean"},["integer"]={["number"]="boolean",["integer"]="boolean",["nil"]="boolean"},["string"]={["string"]="boolean",["nil"]="boolean"},["boolean"]={["boolean"]="boolean",["nil"]="boolean"},["record"]={["emptytable"]="boolean",["record"]="boolean",["nil"]="boolean"},["array"]={["emptytable"]="boolean",["array"]="boolean",["nil"]="boolean"},["map"]={["emptytable"]="boolean",["map"]="boolean",["nil"]="boolean"},["thread"]={["thread"]="boolean",["nil"]="boolean"}}local gY={["#"]={["enum"]="integer",["string"]="integer",["array"]="integer",["tupletable"]="integer",["map"]="integer",["emptytable"]="integer"},["-"]={["number"]="number",["integer"]="integer"},["~"]={["number"]="integer",["integer"]="integer"},["not"]={["string"]="boolean",["number"]="boolean",["integer"]="boolean",["boolean"]="boolean",["record"]="boolean",["array"]="boolean",["tupletable"]="boolean",["map"]="boolean",["emptytable"]="boolean",["thread"]="boolean"}}local gZ={["#"]="__len",["-"]="__unm",["~"]="__bnot"}local g_={["+"]=gT,["-"]=gT,["*"]=gT,["%"]=gT,["/"]=gU,["//"]=gT,["^"]=gU,["&"]=gV,["|"]=gV,["<<"]=gV,[">>"]=gV,["~"]=gV,["=="]=gX,["~="]=gX,["<="]=gW,[">="]=gW,["<"]=gW,[">"]=gW,["or"]={["boolean"]={["boolean"]="boolean"},["number"]={["integer"]="number",["number"]="number",["boolean"]="boolean"},["integer"]={["integer"]="integer",["number"]="number",["boolean"]="boolean"},["string"]={["string"]="string",["boolean"]="boolean",["enum"]="string"},["function"]={["boolean"]="boolean"},["array"]={["boolean"]="boolean"},["record"]={["boolean"]="boolean"},["map"]={["boolean"]="boolean"},["enum"]={["string"]="string"},["thread"]={["boolean"]="boolean"}},[".."]={["string"]={["string"]="string",["enum"]="string",["number"]="string",["integer"]="string"},["number"]={["integer"]="string",["number"]="string",["string"]="string",["enum"]="string"},["integer"]={["integer"]="string",["number"]="string",["string"]="string",["enum"]="string"},["enum"]={["number"]="string",["integer"]="string",["string"]="string",["enum"]="string"}}}local h0={["+"]="__add",["-"]="__sub",["*"]="__mul",["/"]="__div",["%"]="__mod",["^"]="__pow",["//"]="__idiv",["&"]="__band",["|"]="__bor",["~"]="__bxor",["<<"]="__shl",[">>"]="__shr",[".."]="__concat",["=="]="__eq",["<"]="__lt",["<="]="__le",["@index"]="__index",["is"]="__is"}local h1={[">"]="__lt",[">="]="__le"}local function h2(aa)return aa.typename=="unknown"or aa.typename=="unresolved_emptytable_value"end;local function h3(h4,h5)return m and h5 .." "..h4 or h4:gsub("@.*","")end;local function h6(aa,h7)if aa.declname then return" "..aa.declname end;local fo={}table.insert(fo," (")if aa.elements then table.insert(fo,"{"..h7(aa.elements).."}")end;local h8={}for E,ac in ipairs(aa.field_order)do local aP=aa.fields[ac]table.insert(h8,ac..": "..h7(aP))end;table.insert(fo,table.concat(h8,"; "))table.insert(fo,")")return table.concat(fo)end;local function h9(aa,ha,hb)if hb[aa]then return hb[aa]end;hb[aa]="..."local function h7(aL)return aD(aL,ha,hb)end;if aa.typename=="nominal"then local eU;if aa.typevals then local fo={table.concat(aa.names,"."),"<"}local hc={}for E,aP in ipairs(aa.typevals)do table.insert(hc,h7(aP))end;table.insert(fo,table.concat(hc,", "))table.insert(fo,">")eU=table.concat(fo)else eU=table.concat(aa.names,".")end;if m then eU="nominal "..eU end;return eU elseif aa.typename=="self"then if aa.display_type then local eU=h9(aa.display_type,ha,hb)if m then eU="self "..eU end;return eU end;return"self"elseif aa.typename=="tuple"then local fo={}for E,aP in ipairs(aa.tuple)do table.insert(fo,h7(aP))end;local ag=table.concat(fo,", ")if aa.is_va then ag=ag.."..."end;if ha then return ag end;return"("..ag..")"elseif aa.typename=="tupletable"then local fo={}for E,aP in ipairs(aa.types)do table.insert(fo,h7(aP))end;return"{"..table.concat(fo,", ").."}"elseif aa.typename=="poly"then local fo={}for E,aP in ipairs(aa.types)do table.insert(fo,h7(aP))end;return"polymorphic function (with types "..table.concat(fo," and ")..")"elseif aa.typename=="union"then local fo={}for E,aP in ipairs(aa.types)do table.insert(fo,h7(aP))end;return table.concat(fo," | ")elseif aa.typename=="emptytable"then return"{}"elseif aa.typename=="map"then return"{"..h7(aa.keys).." : "..h7(aa.values).."}"elseif aa.typename=="array"then return"{"..h7(aa.elements).."}"elseif aa.typename=="enum"then return aa.declname or"enum"elseif aa.fields then return ha and(aa.declname or aa.typename)or aa.typename..h6(aa,h7)elseif aa.typename=="function"then local fo={"function("}local cP={}for J,aP in ipairs(aa.args.tuple)do table.insert(cP,(J==#aa.args.tuple and aa.args.is_va and"...: "or J>aa.min_arity and"? "or"")..h7(aP))end;table.insert(fo,table.concat(cP,", "))table.insert(fo,")")if aa.rets.tuple and#aa.rets.tuple>0 then table.insert(fo,": ")local fW={}if#aa.rets.tuple>1 then table.insert(fo,"(")end;for J,aP in ipairs(aa.rets.tuple)do table.insert(fW,h7(aP)..(J==#aa.rets.tuple and aa.rets.is_va and"..."or""))end;table.insert(fo,table.concat(fW,", "))if#aa.rets.tuple>1 then table.insert(fo,")")end end;return table.concat(fo)elseif aa.typename=="generic"then local fo={}local u,hd;local bR=aa.t;if bR.typename=="record"or bR.typename=="interface"or bR.typename=="function"then u,hd=h7(bR):match("^(%a+)(.*)")table.insert(fo,u)else hd=" "..h7(bR)table.insert(fo,"generic")end;table.insert(fo,"<")local by={}for E,aP in ipairs(aa.typeargs)do table.insert(by,h7(aP))end;table.insert(fo,table.concat(by,", "))table.insert(fo,">")table.insert(fo,hd)return table.concat(fo)elseif aa.typename=="number"or aa.typename=="integer"or aa.typename=="boolean"or aa.typename=="thread"then return aa.typename elseif aa.typename=="string"then if ha then return"string"else return aa.typename..(aa.literal and string.format(" %q",aa.literal)or"")end elseif aa.typename=="typevar"then return h3(aa.typevar,"typevar")elseif aa.typename=="typearg"then return h3(aa.typearg,"typearg")elseif aa.typename=="unresolvable_typearg"then return h3(aa.typearg,"typearg").." (unresolved generic)"elseif h2(aa)then return"<unknown type>"elseif aa.typename=="invalid"then return"<invalid type>"elseif aa.typename=="any"then return"<any type>"elseif aa.typename=="nil"then return"nil"elseif aa.typename=="boolean_context"then return"boolean"elseif aa.typename=="none"then return""elseif aa.typename=="typedecl"then return(aa.is_alias and"type alias to "or"type ")..h7(aa.def)else return"<"..aa.typename..">"end end;local function he(aa,gy)return" ("..(gy or"").."inferred at "..aa.inferred_at.f..":"..aa.inferred_at.y..":"..aa.inferred_at.x..")"end;aD=function(aa,ha,hb)hb=hb or{}if hb[aa]then return hb[aa]end;local eU=h9(aa,ha,hb)if aa.inferred_at then eU=eU..he(aa)end;hb[aa]=eU;return eU end;local function hf(hg,hh,hi,hj)for hk in hi:gmatch("[^;]+")do local hl=hg:gsub("%.","/")local L=hk:gsub("?",hl)local hm=L:gsub("%.lua$",hh)local hn=io.open(hm,"rb")if hn then return hm,hn,hj end;table.insert(hj,"no file '"..hm.."'")end;return nil,nil,hj end;h.search_module=function(hg,ho)local ap;local hn;local hj={}local hi=os.getenv("TL_PATH")or h.path or package.path;if ho then ap,hn,hj=hf(hg,".d.tl",hi,hj)if ap then return ap,hn end end;ap,hn,hj=hf(hg,".tl",hi,hj)if ap then return ap,hn end;if ho then ap,hn,hj=hf(hg,".lua",hi,hj)if ap then return ap,hn end end;return nil,nil,hj end;local function hp(aG,hg,d0,hq)local hr=hq.modules[hg]if hr then return hr,hq.module_filenames[hg]end;local ap,hn=h.search_module(hg,true)if ap and(d0.feat_lax=="on"or ap:match("tl$"))then hq.module_filenames[hg]=ap;hq.modules[hg]=aF(aG,"typedecl",{def=aF(aG,"circular_require",{})})local hs=hq.defaults;local ht={feat_lax=d0.feat_lax or hs.feat_lax,feat_arity=d0.feat_arity or hs.feat_arity,gen_compat=d0.gen_compat or hs.gen_compat,gen_target=d0.gen_target or hs.gen_target,run_internal_compiler_checks=d0.run_internal_compiler_checks or hs.run_internal_compiler_checks}hq.defaults=ht;local hu,aW=h.check_file(ap,hq,hn)assert(hu,aW)hq.defaults=hs;hq.modules[hg]=hu.type;return hu.type,ap elseif hn then hn:close()end;return aF(aG,"invalid",{}),ap end;local hv={}local function hw(hx,hy,hz)if hz=="off"or not next(hy)then return end;local hA=m;m=nil;local hB=fR(hy)local hC=false;local b2=1;local function hD(u,hE)local fO=hv[u]if not fO then fO=h.parse(hE,"@internal","lua")h.check(fO,"@internal",{feat_lax="off",gen_compat="off"})hv[u]=fO end;for E,y in ipairs(fO)do table.insert(hx,b2,y)b2=b2+1 end end;local function hF(c)return hz=="optional"and"pcall(require, '"..c.."')"or"true, require('"..c.."')"end;for E,u in ipairs(hB)do if u=="table.unpack"then hD(u,"local _tl_table_unpack = unpack or table.unpack")elseif u=="table.pack"then hD(u,[[local _tl_table_pack = table.pack or function(...) return { n = select("#", ...), ... } end]])elseif u=="bit32"then hD(u,"local bit32 = bit32; if not bit32 then local p, m = "..hF("bit32").."; if p then bit32 = m end")elseif u=="mt"then hD(u,"local _tl_mt = function(m, s, a, b) return (getmetatable(s == 1 and a or b)[m](a, b) end")elseif u=="math.maxinteger"then hD(u,"local _tl_math_maxinteger = math.maxinteger or math.pow(2,53)")elseif u=="math.mininteger"then hD(u,"local _tl_math_mininteger = math.mininteger or -math.pow(2,53) - 1")elseif u=="type"then hD(u,"local type = type")else if not hC then hD("compat","local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = "..hF("compat53.module").."; if p then _tl_compat = m end")hC=true end;hD(u,("local $NAME = _tl_compat and _tl_compat.$NAME or $NAME"):gsub("$NAME",u))end end;hx.y=1;m=hA end;local function hG()return{["io"]=true,["math"]=true,["string"]=true,["table"]=true,["utf8"]=true,["coroutine"]=true,["os"]=true,["package"]=true,["debug"]=true,["load"]=true,["loadfile"]=true,["assert"]=true,["pairs"]=true,["ipairs"]=true,["pcall"]=true,["xpcall"]=true,["rawlen"]=true}end;local hH={["&"]="band",["|"]="bor",["~"]="bxor",[">>"]="rshift",["<<"]="lshift"}local function hI(aG,b2)b2.f=assert(aG.f)b2.x=aG.x;b2.y=aG.y;return b2 end;local function hJ(b4,hK,hL,cJ,hM)b4.op.op="@funcall"b4.op.arity=2;b4.op.prec=100;b4.e1=hI(b4,{kind="op",op=aM(b4,2,".")})b4.e1.e1=hI(b4,{kind="identifier",tk=hK})b4.e1.e2=hI(b4,{kind="identifier",tk=hL})b4.e2=hI(b4,{kind="expression_list"})b4.e2[1]=cJ;b4.e2[2]=hM end;local function hN(b4,hO,hP,cJ,hM)b4.op.op="@funcall"b4.op.arity=2;b4.op.prec=100;b4.e1=hI(b4,{kind="identifier",tk="_tl_mt"})b4.e2=hI(b4,{kind="expression_list"})b4.e2[1]=hI(b4,{kind="string",tk="\""..hO.."\""})b4.e2[2]=hI(b4,{kind="integer",tk=tostring(hP)})b4.e2[3]=cJ;b4.e2[4]=hM end;local hQ=nil;local hR=ar()local hS=1;local function hT(aS,u)if#aS~=0 then local fo={}for E,aW in ipairs(aS)do table.insert(fo,aW.y..":"..aW.x.." "..aW.msg.."\n")end;error("Internal Compiler Error: standard library contains "..u..":\n"..table.concat(fo),2)end end;h.new_env=function(d0)d0=d0 or{}local hq={modules={},module_filenames={},loaded={},loaded_order={},globals={},defaults=d0.defaults or{}}if hq.defaults.gen_target=="5.4"and hq.defaults.gen_compat~="off"then return nil,"gen-compat must be explicitly 'off' when gen-target is '5.4'"end;local aG={f="@stdlib",x=1,y=1}if not hQ then local hA=m;m=nil;local hx,hU=h.parse(f,"stdlib.d.tl","tl")hT(hU,"syntax errors")local hV=h.check(hx,"@stdlib",{},hq)hT(hV.type_errors,"type errors")hQ=hq.globals;m=hA;local hW=hQ["math"].t.def;local hX=hQ["table"].t.def;hW.fields["maxinteger"].needs_compat=true;hW.fields["mininteger"].needs_compat=true;hX.fields["pack"].needs_compat=true;hX.fields["unpack"].needs_compat=true;hQ["..."]={t=aK(aG,{aF(aG,"string",{})})}hQ["@is_va"]={t=aF(aG,"any",{})}hq.globals={}end;local hY=hG()for u,ee in pairs(hQ)do hq.globals[u]=ee;ee.needs_compat=hY[u]local aa=ee.t;if aa.typename=="typedecl"then hq.modules[u]=aa end end;if d0.predefined_modules then for E,u in ipairs(d0.predefined_modules)do local hZ={feat_lax=hq.defaults.feat_lax,feat_arity=hq.defaults.feat_arity}local h_=hp(aG,u,hZ,hq)if h_.typename=="invalid"then return nil,string.format("Error: could not predefine module '%s'",u)end end end;return hq end;do local i0={}function i0:find_var(u,i1)for J=#self.st,1,-1 do local eb=self.st[J]local ee=eb.vars[u]if ee then if i1=="lvalue"and ee.is_specialized and ee.is_specialized~="localizing"then if ee.specialized_from then ee.has_been_written_to=true;return{t=ee.specialized_from,attribute=ee.attribute},J,ee.attribute end else if J==1 and ee.needs_compat then self.all_needs_compat[u]=true end;if i1=="use_type"then ee.used_as_type=true elseif i1~="check_only"then if i1=="lvalue"then ee.has_been_written_to=true else ee.has_been_read_from=true end end;return ee,J,ee.attribute end end end end;function i0:simulate_g()local g8={}for ac,aP in pairs(self.st[1].vars)do if ac:sub(1,1)~="@"then g8[ac]=aP.t end end;return{typeid=hR,typename="record",field_order=fR(g8),fields=g8},nil end;local i2;local i3={["typevar"]=function(by,aa)for E,i4 in ipairs(by)do if i4.typearg==aa.typevar then return aF(aa,"typevar",{typevar=aa.typevar:gsub("@.*","").."@"..hS,constraint=aa.constraint}),true end end;return aa,false end,["typearg"]=function(by,aa)for E,i4 in ipairs(by)do if i4.typearg==aa.typearg then return aF(aa,"typearg",{typearg=aa.typearg:gsub("@.*","").."@"..hS,constraint=aa.constraint}),true end end;return aa,false end}local function i5(self,i6)hS=hS+1;local i7,V=i2(i6.typeargs,i6,i3)if i7.typename=="invalid"then self.errs:collect(V)return i6 end;assert(i7.typename=="generic","Internal Compiler Error: error creating fresh type variables")assert(i7~=i6)i7.fresh=true;return i7 end;local function i8(by,aa)if not by then return aa end;assert(not(aa.typename=="typedecl"))local bz=aF(aa,"generic",{t=aa})bz.typeargs=by;return bz end;function i0:find_var_type(u,i1)local ee=self:find_var(u,i1)if ee then local aa=ee.t;if aa.typename=="unresolved_typearg"then return nil,nil,aa.constraint end;if aa.typename=="generic"then aa=i5(self,aa)end;return aa,ee.attribute end end;local function i9(aa)if aa.typename=="generic"then local bR=i9(aa.t)if bR~=aa.t then local ia=aN(aa)ia.t=bR;return ia end end;if aa.typename=="function"and aa.is_method then aa=aN(aa)aa.is_method=false end;return aa end;local function ib(aL)if aL.typename=="nominal"and aL.found then return ib(aL.found)elseif aL.typename=="typedecl"then return ib(aL.def)elseif aL.typename=="generic"then return ib(aL.t)end;return aL end;function i0:find_type(de)local aL=self:find_var_type(de[1],"use_type")if not aL then if#de==1 and de[1]=="metatable"then return self:find_type({"_metatable"})end;return nil end;for J=2,#de do aL=ib(aL)if aL==nil then return nil end;local dE=aL.fields and aL.fields;if not dE then return nil end;aL=dE[de[J]]end;if aL and aL.typename=="nominal"then aL=aL.found end;if aL==nil then return nil end;if aL.typename=="typedecl"then return aL elseif aL.typename=="typearg"then return nil,aL end end;local function ic(aa)if aa.typename=="typedecl"then return ic(aa.def)elseif aa.typename=="tuple"then return ic(aa.tuple[1]),aa.tuple[1]elseif aa.typename=="nominal"then local id=aa.found;if not id then return"invalid"end;return ic(id)elseif aa.fields then if aa.is_userdata then return"userdata",aa end;return"table",aa elseif aa.typename=="generic"then return ic(aa.t)elseif as[aa.typename]then return"table",aa else return aa.typename,aa end end;local function ie(aL)local ig=0;local ih=0;local ii=0;local ij=0;local ik=0;local il=0;local im=false;for E,aa in ipairs(aL.types)do local ip,fV=ic(aa)if ip=="userdata"then assert(fV.fields)if fV.meta_fields and fV.meta_fields["__is"]then ik=ik+1;if ij>0 then return false,"cannot mix userdata types with and without __is metamethod: %s"end else ij=ij+1;if ij>1 then return false,"cannot discriminate a union between multiple userdata types: %s"end;if ik>0 then return false,"cannot mix userdata types with and without __is metamethod: %s"end end elseif ip=="table"then if fV.fields and fV.meta_fields and fV.meta_fields["__is"]then ih=ih+1;if ig>0 then return false,"cannot mix table types with and without __is metamethod: %s"end else ig=ig+1;if ig>1 then return false,"cannot discriminate a union between multiple table types: %s"end;if ih>0 then return false,"cannot mix table types with and without __is metamethod: %s"end end elseif ip=="function"then ii=ii+1;if ii>1 then return false,"cannot discriminate a union between multiple function types: %s"end elseif ip=="enum"or ip=="string"and not im then il=il+1;if il>1 then return false,"cannot discriminate a union between multiple string/enum types: %s"end;if ip=="string"then im=true end elseif ip=="invalid"then return false,nil end end;return true end;local function iq(ct)local ir=#ct.args.tuple;if ct.min_arity<ir then if ct.min_arity>0 then return"at least "..ct.min_arity..(ct.args.is_va and""or" and at most "..ir)else return ct.args.is_va and"any number"or"at most "..ir end else return tostring(ir or 0)end end;local function is(aa)if aa.typename=="string"and aa.literal then local eU=aN(aa)eU.literal=nil;return eU end;return aa end;local function it(aa)if aa.typename=="typedecl"then return aa.def else return aa end end;local iu={["string"]=true,["number"]=true,["integer"]=true,["boolean"]=true,["thread"]=true,["any"]=true,["enum"]=true,["nil"]=true,["unknown"]=true}local iv;do local iw={["typevar"]=function(ak,aa)local fV=ak.tc:find_var_type(aa.typevar)if not fV then return aa,false end;fV=is(fV)ak.resolved[aa.typevar]=fV;return fV,true end}local function ix(aO,g1)for J=#aO.typeargs,1,-1 do local cx=g1[aO.typeargs[J].typearg]if cx then table.remove(aO.typeargs,J)end end;if not aO.typeargs[1]then return aO.t end;return aO end;iv=function(self,aa)local N={tc=self,resolved={}}local fV,V=i2(N,aa,iw)if V then return fV,V end;if fV.typename=="generic"then fV=ix(fV,N.resolved)end;return fV end end;i2=function(self,Y,iy)local V;local hb={}local iz;iz=function(aa,iA)local iB=true;if iu[aa.typename]or aa.typename=="nominal"and not aa.typevals then return aa,iA end;if hb[aa]then return hb[aa],iA end;local iC=aa;local dd=iy[aa.typename]if dd then local fV,iD=dd(self,aa)if fV~=aa then if iD then hb[aa]=fV;return fV,false end;return iz(fV,false)end end;local aO={}hb[iC]=aO;setmetatable(aO,aE)aO.typename=aa.typename;aO.f=aa.f;aO.x=aa.x;aO.y=aa.y;if aa.typename=="generic"then assert(aO.typename=="generic")local iE={}for J,iF in ipairs(aa.typeargs)do iE[J],iB=iz(iF,iB)end;aO.typeargs=iE;aO.t,iB=iz(aa.t,iB)elseif aa.typename=="array"then assert(aO.typename=="array")aO.elements,iB=iz(aa.elements,iB)elseif aa.typename=="typearg"then assert(aO.typename=="typearg")aO.typearg=aa.typearg;if aa.constraint then aO.constraint,iB=iz(aa.constraint,iB)end elseif aa.typename=="unresolvable_typearg"then assert(aO.typename=="unresolvable_typearg")aO.typearg=aa.typearg elseif aa.typename=="unresolved_emptytable_value"then assert(aO.typename=="unresolved_emptytable_value")aO.emptytable_type=aa.emptytable_type elseif aa.typename=="typevar"then assert(aO.typename=="typevar")aO.typevar=aa.typevar;if aa.constraint then aO.constraint,iB=iz(aa.constraint,iB)end elseif aa.typename=="typedecl"then assert(aO.typename=="typedecl")aO.def,iB=iz(aa.def,iB)aO.is_alias=aa.is_alias;aO.is_nested_alias=aa.is_nested_alias elseif aa.typename=="nominal"then assert(aO.typename=="nominal")aO.names=aa.names;aO.typevals={}for J,iF in ipairs(aa.typevals)do aO.typevals[J],iB=iz(iF,iB)end;aO.found=aa.found elseif aa.typename=="function"then assert(aO.typename=="function")aO.macroexp=aa.macroexp;aO.min_arity=aa.min_arity;aO.is_method=aa.is_method;aO.is_record_function=aa.is_record_function;aO.args,iB=iz(aa.args,iB)aO.rets,iB=iz(aa.rets,iB)elseif aa.fields then assert(aO.typename=="record"or aO.typename=="interface")aO.declname=aa.declname;if aa.elements then aO.elements,iB=iz(aa.elements,iB)end;if aa.interface_list then aO.interface_list={}for J,aP in ipairs(aa.interface_list)do aO.interface_list[J],iB=iz(aP,iB)end end;aO.is_userdata=aa.is_userdata;aO.fields={}aO.field_order={}for J,ac in ipairs(aa.field_order)do aO.field_order[J]=ac;aO.fields[ac],iB=iz(aa.fields[ac],iB)end;if aa.meta_fields then aO.meta_fields={}aO.meta_field_order={}for J,ac in ipairs(aa.meta_field_order)do aO.meta_field_order[J]=ac;aO.meta_fields[ac],iB=iz(aa.meta_fields[ac],iB)end end elseif aa.typename=="map"then assert(aO.typename=="map")aO.keys,iB=iz(aa.keys,iB)aO.values,iB=iz(aa.values,iB)elseif aa.typename=="union"then assert(aO.typename=="union")aO.types={}for J,iF in ipairs(aa.types)do aO.types[J],iB=iz(iF,iB)end;local E,aW=ie(aO)if aW then V=V or{}table.insert(V,gm(aW,aO))end elseif aa.typename=="poly"then assert(aO.typename=="poly")aO.types={}for J,iF in ipairs(aa.types)do aO.types[J],iB=iz(iF,iB)end elseif aa.typename=="tupletable"then assert(aO.typename=="tupletable")aO.inferred_at=aa.inferred_at;aO.types={}for J,iF in ipairs(aa.types)do aO.types[J],iB=iz(iF,iB)end elseif aa.typename=="tuple"then assert(aO.typename=="tuple")aO.is_va=aa.is_va;aO.tuple={}for J,iF in ipairs(aa.tuple)do aO.tuple[J],iB=iz(iF,iB)end elseif aa.typename=="self"then assert(aO.typename=="self")if aa.display_type~=nil then aO.display_type,iB=iz(aa.display_type,iB)end end;aO.typeid=iB and aa.typeid or ar()return aO,iB and iA end;local aO=iz(Y,true)if V then return aF(Y,"invalid",{}),V end;return aO end;function i0:infer_emptytable(iG,iH)local gN=iG.declared_at and iG.declared_at.kind=="global_declaration"local iI=gN and 1 or#self.st;for J=iI,1,-1 do local eb=self.st[J]if eb.vars[iG.assigned_to]then eb.vars[iG.assigned_to]={t=iH}end end end;local function iJ(aa)local fV=aa;if fV.typename=="tuple"then fV=fV.tuple[1]end;if fV==nil then return aF(aa,"nil",{})end;return fV end;function i0:check_if_redeclaration(iK,b4,aa)local iL=self:find_var(iK,"check_only")if iL or aa.typename=="typedecl"and b0[iK]then local gB=b4.tk;local gC="variable"if b4.kind=="local_function"or b4.kind=="record_function"then gC="function"gB=b4.name.tk end;self.errs:redeclaration_warning(b4,gB,gC,iL)end end;local function iM(aG,aa)aa.x=aG.x;aa.y=aG.y;return aa end;function i0:assert_resolved_typevars_at(aG,aa)local eU,V=iv(self,aa)if V then assert(aG.y)self.errs:add_prefixing(aG,V,"")end;if eU.typeid~=aa.typeid then return self:assert_resolved_typevars_at(aG,eU)end;if eU==aa or aa.typename=="typevar"then eU=aN(eU)end;return iM(aG,eU)end;function i0:infer_at(aG,aa)local eU=self:assert_resolved_typevars_at(aG,aa)if eU.typename=="invalid"then eU=aa end;if eU==aa or aa.typename=="typevar"then eU=aN(eU)end;assert(aG.f)eU.inferred_at=aG;return eU end;do local function iN(eb,b4,u,aa,iO,iP)local ee=eb.vars[u]if ee then if ee.is_specialized then ee.t=aa;return ee end;ee.is_specialized=iP;ee.specialized_from=ee.t;ee.t=aa else ee={t=aa,attribute=iO,is_specialized=iP,declared_at=b4}eb.vars[u]=ee end;if iP=="widen"then eb.widens=eb.widens or{}eb.widens[u]=true else eb.narrows=eb.narrows or{}eb.narrows[u]=true end;return ee end;function i0:add_var(b4,u,aa,iO,iP)if self.feat_lax and b4 and h2(aa)and(u~="self"and u~="...")and not iP then self.errs:add_unknown(b4,u)end;if not iO then aa=is(aa)end;if self.collector and b4 then self.collector.add_to_symbol_list(b4,u,aa)end;local eb=self.st[#self.st]if iP then return iN(eb,b4,u,aa,iO,iP)end;if b4 then if u~="self"and u~="..."and u:sub(1,1)~="@"then self:check_if_redeclaration(u,b4,aa)end;if not gK(aa)then b4.elide_type=true end end;local ee=eb.vars[u]if ee and not gL(ee)then self.errs:unused_warning(u,ee)end;ee={t=aa,attribute=iO,declared_at=b4}eb.vars[u]=ee;return ee end end;function i0:has_all_types_of(iQ,iR)for E,cL in ipairs(iQ)do local ap=false;for E,gn in ipairs(iR)do if self:same_type(gn,cL)then ap=true;break end end;if not ap then return false end end;return true end;local function iS(iT)if#iT==0 then return true else return false,iT end end;local function iU(aa)if aa.closed then return end;local iV=aa.def;if iV.fields then aa.closed=true;for E,g3 in pairs(iV.fields)do if g3.typename=="typedecl"then iU(g3)end end end end;local function iW(eb)for E,ee in pairs(eb.vars)do local aa=ee.t;if aa.typename=="typedecl"then iU(aa)end end end;function i0:widen_in_scope(b2,ee)local eb=self.st[b2]local aP=eb.vars[ee]assert(aP,"no "..ee.." in scope")local iP=eb.vars[ee].is_specialized;if not iP or not(iP=="narrow"or iP=="narrowed_declaration")then return false end;local iX=#self.st;if b2~=iX then local aa=aP.specialized_from;if not aa then local iL;for J=b2-1,1,-1 do iL=self.st[J].vars[ee]if iL then if iL.specialized_from then aa=iL.specialized_from;break elseif iL.is_specialized=="localizing"or not iL.is_specialized then aa=iL.t;break end end end;if not aa then return false end end;self:add_var(nil,ee,aa,nil,"widen")return true end;if aP.specialized_from then aP.t=aP.specialized_from;aP.specialized_from=nil;aP.is_specialized=nil else eb.vars[ee]=nil end;if eb.narrows then eb.narrows[ee]=nil end;return true end;function i0:widen_back_var(u)local iY=false;for J=#self.st,1,-1 do local eb=self.st[J]if eb.vars[u]then if self:widen_in_scope(J,u)then iY=true else break end end end;return iY end;function i0:collect_if_widens(iZ)local ab=self.st;local eb=ab[#ab]if eb.widens then iZ=iZ or{}for ac,E in pairs(eb.widens)do iZ[ac]=true end;eb.widens=nil end;return iZ end;function i0:widen_all(iZ)for u,E in pairs(iZ)do self:widen_back_var(u)end end;function i0:begin_scope(b4)table.insert(self.st,{vars={}})if self.collector and b4 then self.collector.begin_symbol_list_scope(b4)end end;function i0:end_scope(b4)local ab=self.st;local eb=ab[#ab]local i_=#ab-1;local j0=ab[i_]assert(not eb.is_transaction)if j0 then if eb.pending_labels then j0.pending_labels=j0.pending_labels or{}for u,gQ in pairs(eb.pending_labels)do for E,b2 in ipairs(gQ)do j0.pending_labels[u]=j0.pending_labels[u]or{}table.insert(j0.pending_labels[u],b2)end end;eb.pending_labels=nil end;if eb.pending_nominals then j0.pending_nominals=j0.pending_nominals or{}for u,bD in pairs(eb.pending_nominals)do for E,aL in ipairs(bD)do j0.pending_nominals[u]=j0.pending_nominals[u]or{}table.insert(j0.pending_nominals[u],aL)end end;eb.pending_nominals=nil end end;iW(eb)self.errs:check_var_usage(eb)table.remove(ab)if eb.widens then self:widen_all(eb.widens)end;if self.collector and b4 then self.collector.end_symbol_list_scope(b4)end end;function i0:begin_scope_transaction(b4)self:begin_scope(b4)local ab=self.st;ab[#ab].is_transaction=true end;function i0:rollback_scope_transaction()local ab=self.st;local eb=ab[#ab]assert(eb.is_transaction)local gO=eb.vars;for ac,E in pairs(gO)do gO[ac]=nil end;if self.collector then self.collector.rollback_symbol_list_scope()end end;function i0:commit_scope_transaction()local ab=self.st;local eb=ab[#ab]local j0=ab[#ab-1]assert(eb.is_transaction)assert(not eb.pending_labels)assert(not eb.pending_nominals)for u,ee in pairs(eb.vars)do local aa=ee.t;j0.vars[u]=ee;assert(aa)end;table.remove(ab)end;local j1=aF({f="@none",x=-1,y=-1},"none",{})local function j2(self,b4,fA)self:end_scope(b4)return j1 end;local function j3(i6)local j4={}for E,i4 in ipairs(i6.typeargs)do table.insert(j4,aF(i4,"unresolved_typearg",{constraint=i4.constraint}))end;return j4 end;function i0:apply_generic(aG,i6,by)if not i6.fresh then i6=i5(self,i6)end;if not by then by=j3(i6)end;assert(#i6.typeargs==#by)for J,i4 in ipairs(i6.typeargs)do self:add_var(nil,i4.typearg,by[J])end;local j5,V=iv(self,i6)if V then self.errs:add_prefixing(aG,V,"")return nil end;if j5.typename=="generic"then return j5.t,i6.typeargs else return j5,i6.typeargs end end;do local function j6(self,j7,eU)if not eU or not(j7.typename=="nominal")then return end;local ap=j7.found;if not ap then return end;local j8=ap.def;if not(j8.fields and j8.meta_fields and eU.fields)then return end;for fw,fx in pairs(j8.meta_fields)do if eU.fields[fw]then if not self:is_a(fx,eU.fields[fw])then self.errs:add(fx,fw.." does not follow metatable contract: got %s, expected %s",fx,eU.fields[fw])end end;eU.fields[fw]=fx end end;local function j9(self,aa,bB)if not aa.typevals then self.errs:add(aa,"missing type arguments in %s",bB)return nil elseif#aa.typevals~=#bB.typeargs then self.errs:add(aa,"mismatch in number of type arguments")return nil end;self:begin_scope()local eU=self:apply_generic(aa,bB,aa.typevals)if bB==self.cache_std_metatable_type then j6(self,aa.typevals[1],eU)end;self:end_scope()return eU end;local function ja(self,aa)if aa.resolved then return aa.resolved end;local ap=aa.found or self:find_type(aa.names)if not ap then return self.errs:invalid_at(aa,"unknown type %s",aa)end;if ap.typename=="typedecl"and ap.is_alias then local bB=ap.def;if bB.typename=="nominal"then ap=bB.found end end;if not ap then return self.errs:invalid_at(aa,table.concat(aa.names,".").." is not a resolved type")end;if not(ap.typename=="typedecl")then return self.errs:invalid_at(aa,table.concat(aa.names,".").." is not a type")end;local bB=ap.def;if bB.typename=="circular_require"then return bB end;assert(not(bB.typename=="nominal"))aa.found=ap;if self.collector then self.env.reporter:set_ref(aa,ap)end;return nil,ap end;local function jb(self,aa,ap)local bB=ap.def;local g1;if bB.typename=="generic"then g1=j9(self,aa,bB)if not g1 then g1=aF(aa,"invalid",{})end elseif aa.typevals then g1=self.errs:invalid_at(aa,"unexpected type argument")else g1=bB end;aa.resolved=g1;return g1 end;function i0:resolve_nominal(aa)local jc,ap=ja(self,aa)if jc then return jc end;return jb(self,aa,ap)end;function i0:resolve_typealias(i4)local bB=i4.def;local g0=bB;if bB.typename=="generic"then g0=bB.t end;if not(g0.typename=="nominal")then return i4 end;local jc,ap=ja(self,g0)if jc and(jc.typename=="invalid"or jc.typename=="typedecl")then return jc end;if not g0.typevals then g0.resolved=ap;return ap end;local jd=jb(self,g0,ap or g0.found)if bB.typename=="generic"then jd=i8(bB.typeargs,jd)end;local je=aF(i4,"typedecl",{def=jd})g0.resolved=je;return je end end;function i0:arg_check(aG,iT,aX,aY,aP,ck,b2)local bO,aW,V;if aP=="covariant"then bO,V=self:is_a(aX,aY)elseif aP=="contravariant"then bO,V=self:is_a(aY,aX)elseif aP=="bivariant"then bO,V=self:is_a(aX,aY)if bO then return true end;bO=self:is_a(aY,aX)if bO then return true end elseif aP=="invariant"then bO,V=self:same_type(aX,aY)end;if bO and aY.typename=="nominal"then local jf=self:resolve_nominal(aY)bO,aW=gK(jf)if not bO then V={gs(aG,aW)}end end;if not bO then self.errs:add_prefixing(aG,V,ck..(b2 and" "..b2 or"")..": ",iT)return false end;return true end;do local function jg(self,cL,gn)if cL.names[1]==gn.names[1]then local gR=self.st[1]if gR.pending_global_types[cL.names[1]]then return true end end;return false end;local function jh(self,cL,gn)local ji=aD(cL)local jj=aD(gn)if ji==jj then self:resolve_nominal(cL)if cL.found then ji=ji.." (defined in "..cL.found.f..":"..cL.found.y..")"end;self:resolve_nominal(gn)if gn.found then jj=jj.." (defined in "..gn.found.f..":"..gn.found.y..")"end end;return false,{gm(ji.." is not a "..jj)}end;local function jk(self,g0)local id=g0.found;if not id then id=self:find_type(g0.names)if not id then return nil end end;local aa=id.def;if aa.typename=="generic"then aa=aa.t end;return aa end;function i0:are_same_nominals(cL,gn)local jl=jk(self,cL)local jm=jk(self,gn)if not jl or not jm then if jg(self,cL,gn)then return true end;if not jl then self.errs:add(cL,"unknown type %s",cL)end;if not jm then self.errs:add(gn,"unknown type %s",gn)end;return false,{}end;if jl.typeid~=jm.typeid then return jh(self,cL,gn)end;if cL.typevals==nil and gn.typevals==nil then return true end;if cL.typevals and gn.typevals and#cL.typevals==#gn.typevals then local V={}for J=1,#cL.typevals do local E,jn=self:same_type(cL.typevals[J],gn.typevals[J])self.errs:add_prefixing(nil,jn,"type parameter <"..aD(gn.typevals[J])..">: ",V)end;return iS(V)end;return true end end;local jo;function i0:to_structural(aa)assert(not(aa.typename=="tuple"))if aa.typename=="typevar"and aa.constraint then aa=aa.constraint end;if aa.typename=="nominal"then aa=self:resolve_nominal(aa)end;return aa end;local function jp(aG,bD,jq)if#bD==1 then return bD[1]end;local j4={}local gd={}local jr={}jr["nil"]=true;local J=1;while bD[J]or gd[1]do local aa;if gd[1]then aa=table.remove(gd)else aa=bD[J]J=J+1 end;aa=iJ(aa)if aa.typename=="union"then for E,ak in ipairs(aa.types)do table.insert(gd,ak)end else if fh[aa.typename]and(jq or aa.typename=="string"and not aa.literal)then if not jr[aa.typename]then jr[aa.typename]=true;table.insert(j4,aa)end else local js=aa.typeid;if aa.typename=="nominal"and aa.found then js=aa.found.typeid end;if not jr[js]then jr[js]=true;table.insert(j4,aa)end end end end;if jr["invalid"]then return aF(aG,"invalid",{})end;if#j4==1 then return j4[1]else return aF(aG,"union",{types=j4})end end;do local jt={array=true,map=true,record=true,tupletable=true,interface=true}jo=function(aa)return jt[aa.typename]and not(aa.fields and aa.is_userdata)end end;function i0:arraytype_from_tuple(aG,ju)local jv=jp(aG,ju.types,true)local ad=not(jv.typename=="union")and true or ie(jv)if ad then return aF(aG,"array",{elements=jv})end;local jw=aF(aG,"array",{elements=ju.types[1]})for J=2,#ju.types do local jx=self:expand_type(aG,jw,aF(aG,"array",{elements=ju.types[J]}))if not(jx.typename=="array")then return nil,{gm("unable to convert tuple %s to array",ju)}end;jw=jx end;return jw end;local function jy(E,E,E)return true end;function i0:subtype_nominal(aX,aY)local jz=aX.typename=="nominal"and self:resolve_nominal(aX)or aX;local jf=aY.typename=="nominal"and self:resolve_nominal(aY)or aY;local bO,V=self:is_a(jz,jf)if V and#V==1 and V[1].msg:match("^got ")then return false end;return bO,V end;function i0:subtype_array(aX,aY)if not aX.elements or not self:is_a(aX.elements,aY.elements)then return false end;if aX.consttypes and#aX.consttypes>1 then for E,al in ipairs(aX.consttypes)do if not self:is_a(al,aY.elements)then return false,{gm("%s is not a member of %s",al,aY.elements)}end end end;return true end;function i0:in_interface_list(cx,dV)if not cx.interface_list then return false end;for E,aa in ipairs(cx.interface_list)do if self:is_a(aa,dV)then return true end end;return false end;function i0:subtype_record(aX,aY)if aX.elements and aY.elements then if not self:is_a(aX.elements,aY.elements)then return false,{gm("array parts have incompatible element types")}end end;if aX.is_userdata~=aY.is_userdata then return false,{gm(aX.is_userdata and"userdata is not a record"or"record is not a userdata")}end;local V={}for E,ac in ipairs(aX.field_order)do local jA=aX.fields[ac]local jB=aY.fields[ac]if jB then local bO,jC=self:is_a(jA,jB)if not bO then self.errs:add_prefixing(nil,jC,"record field doesn't match: "..ac..": ",V)end end end;if#V>0 then for E,aW in ipairs(V)do aW.msg=aD(aX).." is not a "..aD(aY)..": "..aW.msg end;return false,V end;return true end;function i0:eqtype_record(aX,aY)if aX.elements~=nil~=(aY.elements~=nil)then return false,{gm("types do not have the same array interface")}end;if aX.elements then local bO,V=self:same_type(aX.elements,aY.elements)if not bO then return bO,V end end;local bO,V=self:subtype_record(aX,aY)if not bO then return bO,V end;bO,V=self:subtype_record(aY,aX)if not bO then return bO,V end;return true end;local function jD(self,jA,jB,jE,jF,jG)local jH,jI=self:is_a(jB,jA)local jJ,jK=self:is_a(jE,jF)if jB.typename=="any"and not jG then jH,jI=true,nil end;if jF.typename=="any"and not jG then jJ,jK=true,nil end;if jH and jJ then return true end;for J=1,jI and#jI or 0 do jI[J].msg="in map key: "..jI[J].msg end;for J=1,jK and#jK or 0 do jK[J].msg="in map value: "..jK[J].msg end;if jI and jK then for J=1,#jK do table.insert(jI,jK[J])end;return false,jI end;return false,jI or jK end;function i0:compare_or_infer_typevar(h4,aX,aY,ai)local jL,E,cb=self:find_var_type(h4)if jL then return ai(self,aX or jL,aY or jL)else local gf=aX or aY;if cb then if not self:is_a(gf,cb)then return false,{gm("given type %s does not satisfy %s constraint in type variable "..h3(h4,"typevar"),gf,cb)}end;if self:same_type(gf,cb)then return true end end;local cx,V=iv(self,gf)if V then return false,V end;if cx.typename=="boolean_context"then return true end;if cx.typename=="typevar"and cx.typevar==h4 then return true end;self:add_var(nil,h4,cx)return true end end;function i0:type_of_self(aG)local aa=self:find_var_type("@self")if not aa then return aF(aG,"invalid",{}),nil end;assert(aa.typename=="typedecl")return aa.def,aa end;function i0:exists_supertype_in(aa,eM)for E,Q in ipairs(eM.types)do if self:is_a(aa,Q)then return Q end end end;function i0:forall_are_subtype_of(eM,aa)for E,Q in ipairs(eM.types)do if not self:is_a(Q,aa)then return false end end;return true end;local function jM(self,aX,aY)self:infer_emptytable(aY,self:infer_at(aY,aX))return true end;local function jN(self,aX,aY)if aX.is_userdata then return false,{gm("{} cannot be used with userdata type %s",aX)}end;return jM(self,aX,aY)end;local function jO(self,aG,cj,jP)local jQ=cj.emptytable_type;assert(jQ.typename=="emptytable",cj.typename)local fS=jQ.keys;if not(jP.typename=="emptytable"or jP.typename=="unresolved_emptytable_value")then local jR=at(fS)and aF(aG,"array",{elements=jP})or aF(aG,"map",{keys=fS,values=jP})self:infer_emptytable(jQ,self:infer_at(aG,jR))end end;local function jS(self,aX,aY)if not aX.found or not aY.found then return false end;local aZ=aX.found.def;if aZ.typename=="generic"then aZ=self:apply_generic(aX,aZ,aX.typevals)end;if aZ.fields then if self:in_interface_list(aZ,aY)then return true end end;return self:is_a(aX,self:resolve_nominal(aY))end;local jT={["emptytable"]=jy,["array"]=jy,["map"]=jy,["tupletable"]=jy,["interface"]=function(jU,jV,aY)return not aY.is_userdata end,["record"]=function(jU,jV,aY)return not aY.is_userdata end}i0.eqtype_relations={["typevar"]={["typevar"]=function(self,aX,aY)if aX.typevar==aY.typevar then return true end;return self:compare_or_infer_typevar(aY.typevar,aX,nil,self.same_type)end,["*"]=function(self,aX,aY)return self:compare_or_infer_typevar(aX.typevar,nil,aY,self.same_type)end},["emptytable"]=jT,["tupletable"]={["tupletable"]=function(self,aX,aY)for J=1,math.min(#aX.types,#aY.types)do if not self:same_type(aX.types[J],aY.types[J])then return false,{gm("in tuple entry "..tostring(J)..": got %s, expected %s",aX.types[J],aY.types[J])}end end;if#aX.types~=#aY.types then return false,{gm("tuples have different size",aX,aY)}end;return true end,["emptytable"]=jM},["array"]={["array"]=function(self,aX,aY)return self:same_type(aX.elements,aY.elements)end,["emptytable"]=jM},["map"]={["map"]=function(self,aX,aY)return jD(self,aX.keys,aY.keys,aX.values,aY.values,true)end,["emptytable"]=jM},["union"]={["union"]=function(self,aX,aY)return self:has_all_types_of(aX.types,aY.types)and self:has_all_types_of(aY.types,aX.types)end},["nominal"]={["nominal"]=i0.are_same_nominals,["typedecl"]=function(self,aX,aY)return self:same_type(self:resolve_nominal(aX),aY.def)end},["record"]={["record"]=i0.eqtype_record,["emptytable"]=jN},["interface"]={["interface"]=function(jU,aX,aY)return aX.typeid==aY.typeid end,["emptytable"]=jN},["function"]={["function"]=function(self,aX,aY)local jW=aX.is_method and 1 or 0;local jX,jY=#aX.args.tuple,#aY.args.tuple;if jX~=jY then if not not aX.is_method~=not not aY.is_method then return false,{gm("different number of input arguments: method and non-method are not the same type")}end;return false,{gm("different number of input arguments: got "..jX-jW..", expected "..jY-jW)}end;local jZ,j_=#aX.rets.tuple,#aY.rets.tuple;if jZ~=j_ then return false,{gm("different number of return values: got "..jZ..", expected "..j_)}end;local V={}for J=1,jX do self:arg_check(aX,V,aX.args.tuple[J],aY.args.tuple[J],"invariant","argument",J-jW)end;for J=1,jZ do self:arg_check(aX,V,aX.rets.tuple[J],aY.rets.tuple[J],"invariant","return",J)end;return iS(V)end},["self"]={["self"]=function(jU,jV,k0)return true end,["*"]=function(self,aX,aY)return self:same_type(self:type_of_self(aX),aY)end},["boolean_context"]={["boolean"]=jy},["generic"]={["generic"]=function(self,aX,aY)if#aX.typeargs~=#aY.typeargs then return false end;for J=1,#aX.typeargs do if not self:same_type(aX.typeargs[J],aY.typeargs[J])then return false end end;return self:same_type(aX.t,aY.t)end},["*"]={["boolean_context"]=jy,["self"]=function(self,aX,aY)return self:same_type(aX,self:type_of_self(aY))end,["typevar"]=function(self,aX,aY)return self:compare_or_infer_typevar(aY.typevar,aX,nil,self.same_type)end}}i0.subtype_relations={["nil"]={["*"]=jy},["tuple"]={["tuple"]=function(self,aX,aY)local gA,ci=aX.tuple,aY.tuple;if#gA~=#ci then return false end;for J=1,#gA do if not self:is_a(gA[J],ci[J])then return false end end;return true end,["*"]=function(self,aX,aY)return self:is_a(iJ(aX),aY)end},["typevar"]={["typevar"]=function(self,aX,aY)if aX.typevar==aY.typevar then return true end;return self:compare_or_infer_typevar(aY.typevar,aX,nil,self.is_a)end,["*"]=function(self,aX,aY)return self:compare_or_infer_typevar(aX.typevar,nil,aY,self.is_a)end},["union"]={["nominal"]=function(self,aX,aY)local jf=self:resolve_nominal(aY)if jf.typename=="union"then return self:is_a(aX,jf)end;return self:forall_are_subtype_of(aX,aY)end,["union"]=function(self,aX,aY)local k1={}for E,aa in ipairs(aX.types)do self:begin_scope()local cj=self:exists_supertype_in(aa,aY)self:end_scope()if not cj then return false end;if not k1[cj]then k1[cj]=aa end end;for cj,aa in pairs(k1)do self:is_a(aa,cj)end;return true end,["*"]=i0.forall_are_subtype_of},["poly"]={["*"]=function(self,aX,aY)if self:exists_supertype_in(aY,aX)then return true end;return false,{gm("cannot match against any alternatives of the polymorphic type")}end},["nominal"]={["nominal"]=function(self,aX,aY)local bO,V=self:are_same_nominals(aX,aY)if bO then return true end;local jz=self:resolve_nominal(aX)local jf=self:resolve_nominal(aY)local k2=jz.typename=="union"local k3=jf.typename=="union"if k2 or k3 then return self:is_a(k2 and jz or aX,k3 and jf or aY)end;if jf.typename=="interface"then return jS(self,aX,aY)end;return bO,V end,["union"]=function(self,aX,aY)local jz=self:resolve_nominal(aX)if jz.typename=="union"then return self:is_a(jz,aY)end;return not not self:exists_supertype_in(aX,aY)end,["*"]=i0.subtype_nominal},["enum"]={["string"]=jy},["string"]={["enum"]=function(jU,aX,aY)if not aX.literal then return false,{gm("%s is not a %s",aX,aY)}end;if aY.enumset[aX.literal]then return true end;return false,{gm("%s is not a member of %s",aX,aY)}end},["integer"]={["number"]=jy},["interface"]={["interface"]=function(self,aX,aY)if self:in_interface_list(aX,aY)then return true end;return self:same_type(aX,aY)end,["array"]=i0.subtype_array,["record"]=i0.subtype_record,["tupletable"]=function(self,aX,aY)return self.subtype_relations["record"]["tupletable"](self,aX,aY)end,["emptytable"]=jN},["emptytable"]=jT,["tupletable"]={["tupletable"]=function(self,aX,aY)for J=1,math.min(#aX.types,#aY.types)do if not self:is_a(aX.types[J],aY.types[J])then return false,{gm("in tuple entry "..tostring(J)..": got %s, expected %s",aX.types[J],aY.types[J])}end end;if#aX.types>#aY.types then return false,{gm("tuple %s is too big for tuple %s",aX,aY)}end;return true end,["record"]=function(self,aX,aY)if aY.elements then return self.subtype_relations["tupletable"]["array"](self,aX,aY)end end,["array"]=function(self,aX,aY)if aY.inferred_len and aY.inferred_len>#aX.types then return false,{gm("incompatible length, expected maximum length of "..tostring(#aX.types)..", got "..tostring(aY.inferred_len))}end;local k4,aW=self:arraytype_from_tuple(aX.inferred_at or aX,aX)if not k4 then return false,aW end;if not self:is_a(k4,aY)then return false,{gm("got %s (from %s), expected %s",k4,aX,aY)}end;return true end,["map"]=function(self,aX,aY)local k4=self:arraytype_from_tuple(aX.inferred_at or aX,aX)if not k4 then return false,{gm("Unable to convert tuple %s to map",aX)}end;return jD(self,aF(aX,"integer",{}),aY.keys,k4.elements,aY.values)end,["emptytable"]=jM},["record"]={["record"]=i0.subtype_record,["interface"]=function(self,aX,aY)if self:in_interface_list(aX,aY)then return true end;if not aX.declname then return self:subtype_record(aX,aY)end end,["array"]=i0.subtype_array,["map"]=function(self,aX,aY)if not self:is_a(aY.keys,aF(aY,"string",{}))then return false,{gm("can't match a record to a map with non-string keys")}end;for E,ac in ipairs(aX.field_order)do local jB=aY.keys;if jB.typename=="enum"and not jB.enumset[ac]then return false,{gm("key is not an enum value: "..ac)}end;if not self:is_a(aX.fields[ac],aY.values)then return false,{gm("record is not a valid map; not all fields have the same type")}end end;return true end,["tupletable"]=function(self,aX,aY)if aX.elements then return self.subtype_relations["array"]["tupletable"](self,aX,aY)end end,["emptytable"]=jN},["array"]={["array"]=i0.subtype_array,["record"]=function(self,aX,aY)if aY.elements then return self:subtype_array(aX,aY)end end,["map"]=function(self,aX,aY)return jD(self,aF(aX,"integer",{}),aY.keys,aX.elements,aY.values)end,["tupletable"]=function(self,aX,aY)local k5=aX.inferred_len or 0;if k5>#aY.types then return false,{gm("incompatible length, expected maximum length of "..tostring(#aY.types)..", got "..tostring(k5))}end;for J=1,k5>0 and k5 or#aY.types do if not self:is_a(aX.elements,aY.types[J])then return false,{gm("tuple entry "..J.." of type %s does not match type of array elements, which is %s",aY.types[J],aX.elements)}end end;return true end,["emptytable"]=jM},["map"]={["map"]=function(self,aX,aY)return jD(self,aX.keys,aY.keys,aX.values,aY.values)end,["array"]=function(self,aX,aY)return jD(self,aX.keys,aF(aY,"integer",{}),aX.values,aY.elements)end,["emptytable"]=jM},["typedecl"]={["*"]=function(self,aX,aY)return self:is_a(aX.def,aY)end},["function"]={["function"]=function(self,aX,aY)local V={}local k4,k6=aX.args.tuple,aY.args.tuple;if not aY.args.is_va and(self.feat_arity and(#k4>#k6 and aX.min_arity>aY.min_arity))then table.insert(V,gm("incompatible number of arguments: got "..iq(aX).." %s, expected "..iq(aY).." %s",aX.args,aY.args))else for J=(aX.is_method or aY.is_method)and 2 or 1,#k4 do local k7=k4[J]local k8=k6[J]or aY.args.is_va and k6[#k6]if k8 then self:arg_check(nil,V,k7,k8,"bivariant","argument",J)end end end;local d8,k9=aX.rets.tuple,aY.rets.tuple;local ka=#k9-#d8==1 and aY.rets.is_va;if#d8<#k9 and not ka then table.insert(V,gm("incompatible number of returns: got "..#d8 .." %s, expected "..#k9 .." %s",aX.rets,aY.rets))else local co=#k9;if ka then co=co-1 end;for J=1,co do self:arg_check(nil,V,d8[J],k9[J],"bivariant","return",J)end end;return iS(V)end},["self"]={["self"]=function(jU,jV,k0)return true end,["*"]=function(self,aX,aY)return self:is_a(self:type_of_self(aX),aY)end},["typearg"]={["typearg"]=function(jU,aX,aY)return aX.typearg==aY.typearg end,["*"]=function(self,aX,aY)if aX.constraint then return self:is_a(aX.constraint,aY)end end},["boolean_context"]={["boolean"]=jy},["generic"]={["*"]=function(self,aX,aY)local k4=self:apply_generic(aX,aX)local bO,V=self:is_a(k4,aY)return bO,V end},["*"]={["any"]=jy,["boolean_context"]=jy,["emptytable"]=function(jU,aX,k0)return false,{gm("assigning %s to a variable declared with {}",aX)}end,["unresolved_emptytable_value"]=function(self,aX,aY)jO(self,aY,aY,aX)return true end,["generic"]=function(self,aX,aY)local kb=self:apply_generic(aY,aY)local bO,V=self:is_a(aX,kb)return bO,V end,["self"]=function(self,aX,aY)return self:is_a(aX,self:type_of_self(aY))end,["tuple"]=function(self,aX,aY)return self:is_a(aF(aX,"tuple",{tuple={aX}}),aY)end,["typedecl"]=function(self,aX,aY)return self:is_a(aX,aY.def)end,["typevar"]=function(self,aX,aY)return self:compare_or_infer_typevar(aY.typevar,aX,nil,self.is_a)end,["typearg"]=function(self,aX,aY)if aY.constraint then return self:is_a(aX,aY.constraint)end end,["union"]=i0.exists_supertype_in,["nominal"]=i0.subtype_nominal,["poly"]=function(self,aX,aY)for E,aa in ipairs(aY.types)do if not self:is_a(aX,aa)then return false,{gm("cannot match against all alternatives of the polymorphic type")}end end;return true end}}i0.type_priorities={["generic"]=-1,["nil"]=0,["unresolved_emptytable_value"]=1,["emptytable"]=2,["self"]=3,["tuple"]=4,["typevar"]=5,["typedecl"]=6,["any"]=7,["boolean_context"]=8,["union"]=9,["poly"]=10,["typearg"]=11,["nominal"]=12,["enum"]=13,["string"]=13,["integer"]=13,["boolean"]=13,["interface"]=14,["tupletable"]=15,["record"]=15,["array"]=15,["map"]=15,["function"]=15}local function kc(self,kd,cL,gn)if cL.typeid==gn.typeid then return true end;local gp=kd[cL.typename]local dd=gp and gp[gn.typename]if not dd then local fb=self.type_priorities[cL.typename]or 999;local ke=self.type_priorities[gn.typename]or 999;dd=fb<ke and(gp and gp["*"])or kd["*"][gn.typename]end;local bO,aW;if dd then if dd==jy then return true end;bO,aW=dd(self,cL,gn)else bO=cL.typename==gn.typename end;if not bO and not aW then if cL.typename=="invalid"or gn.typename=="invalid"then return false,{}end;local kf=aD(cL)local kg=aD(gn)if kf==kg then return false,{gs(cL,"types are incompatible")}else return false,{gs(cL,"got "..kf..", expected "..kg)}end end;return bO,aW end;function i0:is_a(cL,gn)return kc(self,self.subtype_relations,cL,gn)end;function i0:same_type(cL,gn)return kc(self,self.eqtype_relations,cL,gn)end;if m then local kh=i0.is_a;i0.is_a=function(self,cL,gn)assert(type(cL)=="table")assert(type(gn)=="table")if cL.typeid==gn.typeid then local ki,kj=h9(cL,false,{}),h9(gn,false,{})assert(ki==kj,ki.." ~= "..kj)return true end;return kh(self,cL,gn)end end;function i0:assert_is_a(aG,cL,gn,gv,u)cL=iJ(cL)gn=iJ(gn)if self.feat_lax and(h2(cL)or gn.typename=="unknown")then return true end;if gn.typename=="emptytable"then gn=iM(aG,gn)end;local bO,kk=self:is_a(cL,gn)if not bO then self.errs:add_prefixing(aG,kk,self.errs:get_context(gv,u))end;return bO end;local function kl(aa)if aa.typename=="invalid"then return false end;if aa.typename=="nil"then return true end;if aa.typename=="nominal"then aa=assert(aa.resolved)end;if aa.fields then return aa.meta_fields and aa.meta_fields["__close"]~=nil end end;local km={["string"]=true,["number"]=true,["integer"]=true,["boolean"]=true,["literal_table"]=true}local function kn(al)return km[al.kind]end;function i0:same_in_all_union_entries(cj,ko)assert(#cj.types>0)local cL,ct=ko(cj.types[1])if not cL then return nil end;for J=2,#cj.types do local gn=ko(cj.types[J])if not gn or not self:same_type(cL,gn)then return nil end end;return ct end;function i0:same_call_mt_in_all_union_entries(cj)return self:same_in_all_union_entries(cj,function(aa)aa=self:to_structural(aa)if aa.fields then local kp=aa.meta_fields and aa.meta_fields["__call"]if kp.typename=="function"then local kq=aF(cj,"tuple",{tuple={}})for J=2,#kp.args.tuple do table.insert(kq.tuple,kp.args.tuple[J])end;return kq,kp end end end)end;function i0:resolve_for_call(kr,cP,ks)if self.feat_lax and h2(kr)then local kt=kr;kr=aJ(kr,{min_arity=0,args=aK(kr,{kt}),rets=aK(kr,{kt})})end;kr=self:to_structural(kr)if kr.typename=="generic"then kr=self:apply_generic(kr,kr)end;if kr.typename=="function"or kr.typename=="poly"then return kr,ks end;if kr.typename=="union"then local cx=self:same_call_mt_in_all_union_entries(kr)if cx then table.insert(cP.tuple,1,kr.types[1])return cx,true end elseif kr.typename=="typedecl"then return self:resolve_for_call(kr.def,cP,ks)elseif kr.fields and kr.meta_fields and kr.meta_fields["__call"]then table.insert(cP.tuple,1,kr)kr=kr.meta_fields["__call"]kr=self:to_structural(kr)ks=true end;if kr.typename=="generic"then kr=self:apply_generic(kr,kr)end;return kr,ks end;local function ku(kv,kw,kx)local f5=kv.exp;local ky={}for J,aX in ipairs(kv.args)do ky[aX.tk]=J end;local f0={cbs={["variable"]={after=function(E,b4,fA)local J=ky[b4.tk]if not J then return nil end;return kw(b4,J)end},["..."]={after=function(E,b4,fA)local J=ky[b4.tk]if not J then return nil end;return kw(b4,J)end}},after=kx}return f4(nil,f5,f0,{})end;local function kz(kA,cP,kv)local kw=function(b4,J)if b4.kind=='...'then local kB={kind="expression_list"}for b2=J,#cP do kB[b2-J+1]=cP[b2]end;return{aC,kB}else return{aC,cP[J]}end end;local kx=function(E,b4,fC,eU)local kC=eU and eU[2]or b4;local fo=aQ(kC)local kD={}for E,kE in pairs(fC)do if type(kE)=="table"then kD[kE[1]]=kE[2]end end;for ac,aP in pairs(kC)do if type(aP)=="table"and kD[aP]then fo[ac]=kD[aP]end end;fo.yend=fo.yend and kA.y+fo.yend-fo.y or nil;fo.xend=nil;fo.y=kA.y;fo.x=kA.x;return{b4,fo}end;local b=ku(kv,kw,kx)kA.expanded=b[2]end;function i0:check_macroexp_arg_use(kv)local k1={}local kw=function(b4,kF)if k1[b4.tk]then self.errs:add(b4,"cannot use argument '"..b4.tk.."' multiple times in macroexp")else k1[b4.tk]=true end end;ku(kv,kw,nil)end;local function kG(kA)local jx=kA.expanded;local kH=kA.known;kA.expanded=nil;for ac,E in pairs(kA)do kA[ac]=nil end;for ac,aP in pairs(jx)do kA[ac]=aP end;kA.known=kH end;do local function kI(self,by)for E,aX in ipairs(by)do if not self:find_var_type(aX.typearg)then if aX.constraint then self:add_var(nil,aX.typearg,aX.constraint)else self:add_var(nil,aX.typearg,self.feat_lax and aF(aX,"unknown",{})or aF(aX,"unresolvable_typearg",{typearg=aX.typearg}))end end end end;local function kJ(self,aG,kK,eM,kL,ft)local kM,g6=eM.tuple,kL.tuple;local kN=#kM;local kO=#g6;for J=1,kN do local Q=kM[J]if Q.typename=="emptytable"then local P=g6[J]or kL.is_va and g6[kO]if P then local kP=kK and kK[J+ft]or aG;local kQ=self:infer_at(kP,P)self:infer_emptytable(Q,kQ)kM[J]=kQ end end end end;local kR;do local kS;do local function kT(self,aG,kK,eM,kL,kU,ft,aP,ck)local V={}local kM,g6=eM.tuple,kL.tuple;local kN=#kM;local kO=#g6;for J=kU,math.max(kN,kO)do local kV=J+ft;local Q=kM[J]or eM.is_va and kM[kN]or aF(aG,"nil",{})local P=g6[J]or kL.is_va and g6[kO]if P then local kP=kK and kK[kV]or aG;if not self:arg_check(kP,V,Q,P,aP,ck,kV)then return nil,V end end end;return true end;kS=function(self,aG,kW,ct,cP,kX,jW)local kY=true;local kZ,k_=true,nil;local kU=1;if jW==-1 then kU=2;local V={}local c2=ct.args.tuple[1]if not(c2.typename=="self")and not self:arg_check(aG,V,c2,cP.tuple[1],"contravariant","self")then return nil,V end end;if kX then kX=self:infer_at(aG,kX)kJ(self,aG,nil,kX,ct.rets,0)kY=kT(self,aG,nil,ct.rets,kX,1,0,"covariant","return")end;kZ,k_=kT(self,aG,kW,ct.args,cP,kU,jW,"contravariant","argument")if not kZ or not kY then return nil,k_ or{}end;kJ(self,aG,kW,cP,ct.args,jW)return true end end;local function l0(self,aG,l1,l2,l3)if l3=="method"or not l2 then return false end;if not(l1 and self:is_a(l1,l2))then self.errs:add(aG,"invoked method as a regular function: use ':' instead of '.'")return true end;if l3=="plain"then self.errs:add_warning("hint",aG,"invoked method as a regular function: consider using ':' instead of '.'")end;return false end;kR=function(self,aG,kW,ct,cP,kX,l3,jW)local l1=cP.tuple[1]if l3=="method"and l1 then local l4=l1;if l4.typename=="self"then l4=self:type_of_self(l4)end;self:add_var(nil,"@self",aF(aG,"typedecl",{def=l4}))end;local l5=ct.args.tuple;if ct.is_method and l0(self,aG,l1,l5[1],l3)then return false end;local l6=#cP.tuple;local l7=#l5;local d1=self.feat_arity and ct.min_arity or 0;if l6<d1 or l6>l7 and not ct.args.is_va then return nil,{gs(aG,"wrong number of arguments (given "..l6 ..", expects "..iq(ct)..")")}end;return kS(self,aG,kW,ct,cP,kX,jW)end end;function i0:iterate_poly(b)local J=0;return function()J=J+1;local l8=b.types[J]if not l8 then return elseif l8.typename=="function"then return J,l8 elseif l8.typename=="generic"then return J,self:apply_generic(b,l8)end end end;local l9;do local function la(self,aG,b,l6)local lb={}for E,ct in self:iterate_poly(b)do table.insert(lb,iq(ct))end;table.sort(lb)for J=#lb,1,-1 do if lb[J]==lb[J+1]then table.remove(lb,J)end end;return{gs(aG,"wrong number of arguments (given "..l6 ..", expects "..table.concat(lb," or ")..")")}end;l9=function(self,aG,kW,b,cP,kX,l3,jW)local l6=#cP.tuple;local hj={}local lc;local ld;for le=1,3 do for J,ct in self:iterate_poly(b)do assert(ct.typename=="function",ct.typename)assert(ct.args)lc=lc or ct.rets;local l7=#ct.args.tuple;local d1=self.feat_arity and ct.min_arity or 0;if not hj[J]and(le==1 and l6==l7 or le==2 and(l6<l7 and l6>=d1)or le==3 and(ct.args.is_va and l6>l7))then local bO,V=kR(self,aG,kW,ct,cP,kX,l3,jW)if bO then return ct,ct.rets elseif kX then kJ(self,aG,kW,ct.rets,ct.rets,jW)end;self:rollback_scope_transaction()ld=ld or V;hj[J]=true end end end;if not ld then return nil,lc,la(self,aG,b,l6)end;return nil,lc,ld end end;local function lf(b4,cJ,ks)if ks then return"method"end;if b3(b4)and cJ and cJ.receiver then local lg=cJ.receiver;if lg.typename=="nominal"then local g1=lg.resolved;if g1 and g1.typename=="typedecl"then return"type_dot"end end end;return"plain"end;function i0:type_check_function_call(b4,kr,cP,jW,cJ,hM)cJ=cJ or b4.e1;hM=hM or b4.e2;local lh=b4.expected;local kX;if lh and lh.typename=="tuple"then kX=lh else kX=aF(b4,"tuple",{tuple={b4.expected}})end;self:begin_scope_transaction(b4)local i6;local by;if kr.typename=="generic"then i6=kr;kr,by=self:apply_generic(b4,kr)end;local ks=jW==-1;if not(kr.typename=="function"or kr.typename=="poly")then kr,ks=self:resolve_for_call(kr,cP,ks)if ks then jW=-1 end end;local l3=lf(b4,cJ,ks)local V;local ct,eU;if kr.typename=="poly"then ct,eU,V=l9(self,b4,hM,kr,cP,kX,l3,jW)elseif kr.typename=="function"then local E;E,V=kR(self,b4,hM,kr,cP,kX,l3,jW)ct,eU=kr,kr.rets else eU=self.errs:invalid_at(b4,"not a function: %s",kr)end;if V then self.errs:collect(V)end;if i6 then kI(self,by)end;self:commit_scope_transaction()eU=self:assert_resolved_typevars_at(b4,eU)if self.collector then self.collector.store_type(cJ.y,cJ.x,ct)end;if ct and ct.macroexp then local li;if ks then li={}if cJ.kind=="op"then table.insert(li,cJ.e1)else table.insert(li,cJ)end;for E,al in ipairs(hM)do table.insert(li,al)end else li=hM end;kz(b4,li,ct.macroexp)end;return eU,ct end end;function i0:check_metamethod(b4,lj,aX,aY,lk,ll,lm)if self.feat_lax and(aX and h2(aX)or aY and h2(aY))then return aF(b4,"unknown",{}),nil end;local ln=aX.fields and aX.meta_fields;local lo=aY and aY.fields and aY.meta_fields;if not ln and not lo then return nil,nil end;local lp=1;local lq;if lj~="__is"then lq=ln and ln[lj or""]end;if not lq and aY and lj~="__index"then lq=lo and lo[lj or""]lp=2 end;if lq then local hM={b4.e1}local cP=aF(b4,"tuple",{tuple={lk}})if aY and lj~="__is"then hM[2]=b4.e2;cP.tuple[2]=ll end;if lm then hM[2],hM[1]=hM[1],hM[2]end;local lr=lq.typename=="function"and lq.is_method and-1 or 0;local ls=self:type_check_function_call(b4,lq,cP,lr,b4,hM)local lt=iJ(ls)local eU=self:to_structural(lt)return eU,lp else return nil,nil end end;local function lu(self,ee,aP,aa)local b4=hI(ee,{kind="op",op={op="is",arity=2,prec=3}})b4.e1=ee;b4.e2=hI(ee,{kind="cast",casttype=self:infer_at(ee,aa)})local E,lv=self:check_metamethod(b4,"__is",self:to_structural(aP),self:to_structural(aa),aP,aa)if b4.expanded then kG(b4)end;b4.known=az({var=ee.tk,typ=aa,w=b4})return b4,lv end;local function lw(self,b4,aP,cj)local ee=b4.e1;b4.op.op="or"b4.op.arity=2;b4.op.prec=1;local lx=nil;b4.e1,lx=lu(self,ee,aP,cj.types[1])local gA=b4;local b2=#cj.types;for J=2,b2-1 do gA.e2=hI(ee,{kind="op",op={op="or",arity=2,prec=1}})local lv;gA.e2.e1,lv=lu(self,ee,aP,cj.types[J])lx=lx or lv;b4.known=ax({f1=gA.e1.known,f2=gA.e2.known,w=b4})gA=gA.e2 end;gA.e2=lu(self,ee,aP,cj.types[b2])b4.known=ax({f1=gA.e1.known,f2=gA.e2.known,w=b4})return not not lx end;function i0:match_record_key(aa,j8,cM)aa=self:to_structural(aa)if aa.typename=="self"then aa=self:type_of_self(aa)end;if aa.typename=="string"or aa.typename=="enum"then aa=self:find_var_type("string")end;if aa.typename=="typedecl"then if aa.is_nested_alias then return nil,"cannot use a nested type alias as a concrete value"end;local bB=aa.def;if bB.typename=="nominal"then assert(aa.is_alias)aa=self:resolve_nominal(bB)else aa=bB end end;if aa.typename=="generic"then aa=self:apply_generic(aa,aa)end;if aa.typename=="union"then local Y=self:same_in_all_union_entries(aa,function(aL)local aP=self:match_record_key(aL,j8,cM)return aP,aP end)if Y then return Y end end;if(aa.typename=="typevar"or aa.typename=="typearg")and aa.constraint then local Y=self:match_record_key(aa.constraint,j8,cM)if Y then return Y end end;local ly=cM:gsub('%%','%%%%')if aa.fields then assert(aa.fields,"record has no fields!?")if aa.fields[cM]then return aa.fields[cM]end;local cs=aF(j8,"string",{})local lz=self:check_metamethod(j8,"__index",aa,cs,aa,cs)if lz then return lz end;if j8.kind=="variable"then if aa.typename=="interface"then return nil,"invalid key '"..ly.."' in '"..j8.tk.."' of interface type %s"else return nil,"invalid key '"..ly.."' in record '"..j8.tk.."' of type %s"end else return nil,"invalid key '"..ly.."' in type %s"end elseif aa.typename=="emptytable"or h2(aa)then if self.feat_lax then return aF(j8,"unknown",{})end;return nil,"cannot index a value of unknown type"end;if j8.kind=="variable"then return nil,"cannot index key '"..ly.."' in variable '"..j8.tk.."' of type %s"else return nil,"cannot index key '"..ly.."' in type %s"end end;local function lA(u,f5)local f0={cbs={["assignment"]={after=function(E,b4,fA)for E,aP in ipairs(b4.vars)do if aP.kind=="variable"and aP.tk==u then return true end end;return false end}},after=function(E,lB,fC,eU)eU=eU or false;for E,y in ipairs(fC)do local lC=y;if type(lC)=="boolean"then eU=eU or y end end;return eU end}local eY={after=function()return false end}return f4(nil,f5,f0,eY)end;function i0:widen_all_unions(b4)for J=#self.st,1,-1 do local eb=self.st[J]if eb.narrows then for u,E in pairs(eb.narrows)do if not b4 or lA(u,b4)then self:widen_in_scope(J,u)end end end end end;function i0:add_global(b4,lD,lE,lF)if self.feat_lax and h2(lE)and(lD~="self"and lD~="...")then self.errs:add_unknown(b4,lD)end;local lG=b4.attribute~=nil;local lH,eb,lI=self:find_var(lD)if lH then if eb>1 then self.errs:add(b4,"cannot define a global when a local with the same name is in scope")elseif lF and lI then self.errs:add(b4,"cannot reassign to <"..lI.."> global: "..lD)elseif lI and not lG then self.errs:add(b4,"global was previously declared as <"..lI..">: "..lD)elseif not lI and lG then self.errs:add(b4,"global was previously declared as not <"..b4.attribute..">: "..lD)elseif lE and not self:same_type(lH.t,lE)then self.errs:add(b4,"cannot redeclare global with a different type: previous type of "..lD.." is %s",lH.t)end;return nil end;local ee={t=lE,attribute=lG and"const"or nil}self.st[1].vars[lD]=ee;return ee end;function i0:add_internal_function_variables(b4,cP)self:add_var(nil,"@is_va",aF(b4,cP.is_va and"any"or"nil",{}))self:add_var(nil,"@return",b4.rets or aF(b4,"tuple",{tuple={}}))if b4.typeargs then for E,aa in ipairs(b4.typeargs)do local aP=self:find_var(aa.typearg,"check_only")if not aP or not aP.used_as_type then self.errs:add(aa,"type argument '%s' is not used in function signature",aa)end end end end;function i0:add_function_definition_for_recursion(b4,lJ,lK)self:add_var(nil,b4.name.tk,i8(b4.typeargs,aJ(b4,{min_arity=lK and b4.min_arity or 0,args=lJ,rets=self.get_rets(b4.rets)})))end;function i0:end_function_scope(b4)self.errs:fail_unresolved_labels(self.st[#self.st])self:end_scope(b4)end;local function lL(aG,jL)local lM=#jL;local eU=aF(aG,"tuple",{tuple={}})local fV=eU.tuple;if lM==0 then return eU end;for J=1,lM-1 do fV[J]=iJ(jL[J])end;local lN=jL[lM]if lN.typename=="tuple"then local dZ=lN.tuple;for E,aP in ipairs(dZ)do table.insert(fV,aP)end;eU.is_va=lN.is_va else fV[lM]=jL[lM]end;return eU end;local function lO(aG,hc,l7)if hc==nil then return aF(aG,"tuple",{tuple={}})end;if hc.is_va then local jL=hc.tuple;local lM=#jL;if lM>0 and lM<l7 then local lN=jL[lM]local eU=aF(aG,"tuple",{tuple={}})local fV=eU.tuple;for J=1,lM do table.insert(fV,jL[J])end;for E=lM+1,l7 do table.insert(fV,lN)end;return eU end end;return hc end;function i0:match_all_record_field_names(b4,aX,lP,lQ)local aa;for E,ac in ipairs(lP)do local ct=aX.fields[ac]if not aa then aa=ct else if not self:same_type(ct,aa)then lQ=lQ..string.format(" (types of fields '%s' and '%s' do not match)",lP[1],ac)aa=nil;break end end end;if aa then return aa else return self.errs:invalid_at(b4,lQ)end end;function i0:type_check_index(lR,lS,aX,aY)assert(not(aX.typename=="tuple"))assert(not(aY.typename=="tuple"))local jz=it(self:to_structural(aX))local jf=self:to_structural(aY)if self.feat_lax and h2(aX)then return aX end;local lT;local lU;local lV;if jz.typename=="tupletable"and jf.typename=="integer"then if lS.constnum then if lS.constnum>=1 and lS.constnum<=#jz.types and lS.constnum==math.floor(lS.constnum)then return jz.types[lS.constnum]end;lT,lU="index "..tostring(lS.constnum).." out of range for tuple %s",jz else local lW=self:arraytype_from_tuple(lS,jz)if lW then return lW.elements end;lT="cannot index this tuple with a variable because it would produce a union type that cannot be discriminated at runtime"end elseif jz.typename=="self"then return self:type_check_index(lR,lS,self:type_of_self(aX),aY)elseif jz.elements and jf.typename=="integer"then return jz.elements elseif jz.typename=="emptytable"then if jz.keys==nil then jz.keys=self:infer_at(lS,aY)end;if self:is_a(aY,jz.keys)then return aF(lR,"unresolved_emptytable_value",{emptytable_type=jz})end;lT,lU,lV="inconsistent index type: got %s, expected %s"..he(jz.keys,"type of keys "),aY,jz.keys elseif jz.typename=="unresolved_emptytable_value"then local jQ=aF(jz,"emptytable",{keys=aY})jO(self,aX,jz,jQ)return aF(lR,"unresolved_emptytable_value",{emptytable_type=jQ})elseif jz.typename=="map"then if self:is_a(aY,jz.keys)then return jz.values end;lT,lU,lV="wrong index type: got %s, expected %s",aY,jz.keys elseif jf.typename=="string"and jf.literal then local aa,al=self:match_record_key(aX,lR,jf.literal)if aa then if aa.typename=="function"and aa.is_method then local gn=aN(aa)gn.args=aN(aa.args)gn.args.tuple=aQ(gn.args.tuple)for J,b in ipairs(gn.args.tuple)do if b.typename=="self"then gn.args.tuple[J]=aX end end;return gn end;return aa end;lT,lU=al,aX elseif jz.fields then if jf.typename=="enum"then local lP=fR(jf.enumset)for E,ac in ipairs(lP)do if not jz.fields[ac]then lT,lU="enum value '"..ac:gsub('%%','%%%%').."' is not a field in %s",jz;break end end;if not lT then return self:match_all_record_field_names(lS,jz,lP,"cannot index, not all enum values map to record fields of the same type")end elseif jf.typename=="string"then lT,lU="cannot index object of type %s with a string, consider using an enum",aX else lT,lU,lV="cannot index object of type %s with %s",aX,aY end else lT,lU,lV="cannot index object of type %s with %s",aX,aY end;local lz=self:check_metamethod(lR,"__index",jz,aY,aX,aY)if lz then return lz end;return self.errs:invalid_at(lS,lT,lU,lV)end;function i0:expand_type(aG,iL,lX)if not iL or iL.typename=="nil"then return lX else if not self:is_a(lX,iL)then if iL.typename=="map"and lX.fields then local lY=iL.keys;if lY.typename=="string"then for E,fx in ex(lX)do iL.values=self:expand_type(aG,iL.values,fx)end;aI(aG,iL,"map")else self.errs:add(aG,"cannot determine table literal type")end elseif iL.fields and lX.fields then local jP;for E,fx in ex(iL)do if not jP then jP=fx else jP=self:expand_type(aG,jP,fx)end end;for E,fx in ex(lX)do if not jP then jP=fx else jP=self:expand_type(aG,jP,fx)end end;iL.fields=nil;iL.field_order=nil;iL.meta_fields=nil;iL.meta_fields=nil;aI(aG,iL,"map")local kD=iL;kD.keys=aF(aG,"string",{})kD.values=jP elseif iL.typename=="union"then aI(aG,iL,"union")table.insert(iL.types,is(lX))else return jp(aG,{iL,lX},true)end end end;return iL end;function i0:find_record_to_extend(e8)if e8.kind=="type_identifier"then local aP=self:find_var(e8.tk)if not aP then return nil,nil,e8.tk end;local aa=aP.t;if aa.typename=="typedecl"then if aa.closed then return nil,nil,e8.tk end;return aa.def,aP,e8.tk end;return aa,aP,e8.tk elseif e8.kind=="op"then local aa,aP,lZ=self:find_record_to_extend(e8.e1)local fw=e8.e2.tk;local l_=lZ.."."..fw;if not aa then return nil,nil,l_ end;if not aa.fields then return nil,nil,l_ end;aa=aa.fields[fw]if aa.typename=="typedecl"then local bB=aa.def;if bB.typename=="nominal"then assert(aa.is_alias)aa=bB.resolved else aa=bB end end;return aa,aP,l_ end end;local function m0(aG,u,aa,g1)local m1;local bB=aa.def;if bB.typename=="generic"then m1={}for E,aX in ipairs(bB.typeargs)do table.insert(m1,aF(aX,"typevar",{typevar=aX.typearg,constraint=aX.constraint}))end end;local g0=aF(aG,"nominal",{names={u}})g0.typevals=m1;g0.found=aa;g0.resolved=g1;return g0 end;function i0:get_self_type(e8)if e8.kind=="type_identifier"then local aa=self:find_var_type(e8.tk)if not aa then return nil end;if aa.typename=="typedecl"then return m0(e8,e8.tk,aa)else return aa end elseif e8.kind=="op"then local aa=self:get_self_type(e8.e1)if not aa then return nil end;if aa.typename=="nominal"then local ap=aa.found;if ap then if ap.typename=="typedecl"then local bB=ap.def;if bB.fields and bB.fields[e8.e2.tk]then table.insert(aa.names,e8.e2.tk)local g3=bB.fields[e8.e2.tk]if g3.typename=="typedecl"then aa.found=g3 else return nil end end end end elseif aa.fields then return aa.fields and aa.fields[e8.e2.tk]end;return aa end end;local m2;local m3;local m4;local m5;do local m6={__tostring=function(ct)return("(%s is %s)"):format(ct.var,aD(ct.typ))end}setmetatable(az,{__call=function(E,m7)m7.fact="is"assert(m7.w)return setmetatable(m7,m6)end})local m8={__tostring=function(ct)return("(%s == %s)"):format(ct.var,aD(ct.typ))end}setmetatable(ay,{__call=function(E,m7)m7.fact="=="assert(m7.w)return setmetatable(m7,m8)end})local m9={__tostring=function(ma)return"*"end}setmetatable(au,{__call=function(E,m7)m7.fact="truthy"return setmetatable(m7,m9)end})local mb={__tostring=function(ct)return("(not %s)"):format(tostring(ct.f1))end}setmetatable(av,{__call=function(E,m7)m7.fact="not"return setmetatable(m7,mb)end})local mc={__tostring=function(ct)return("(%s and %s)"):format(tostring(ct.f1),tostring(ct.f2))end}setmetatable(aw,{__call=function(E,m7)m7.fact="and"return setmetatable(m7,mc)end})local md={__tostring=function(ct)return("(%s or %s)"):format(tostring(ct.f1),tostring(ct.f2))end}setmetatable(ax,{__call=function(E,m7)m7.fact="or"return setmetatable(m7,md)end})m5=au({})m2=function(aG,me,mf)if not me and not mf then return end;return aw({f1=me,f2=mf,w=aG})end;m3=function(aG,me,mf)return ax({f1=me or m5,f2=mf or m5,w=aG})end;m4=function(aG,me)if me then return av({f1=me,w=aG})else return nil end end;local function mg(aG,cL,gn)return jp(aG,{gn,cL})end;local function mh(self,aG,cL,gn)if gn.typename=="union"then cL,gn=gn,cL end;if cL.typename=="union"then local fo={}for E,aa in ipairs(cL.types)do if self:is_a(aa,gn)then table.insert(fo,aa)end end;if#fo>0 then return jp(aG,fo)end end;if self:is_a(cL,gn)then return cL elseif self:is_a(gn,cL)then return gn else return aF(aG,"nil",{})end end;function i0:resolve_if_union(aa)local fV=self:to_structural(aa)if fV.typename=="union"then return fV end;return aa end;local function mi(self,aG,cL,gn)local bD={}cL=self:resolve_if_union(cL)if not(cL.typename=="union")then return cL end;gn=self:resolve_if_union(gn)local mj=gn.typename=="union"and gn.types or{gn}for E,gA in ipairs(cL.types)do local mk=true;for E,ci in ipairs(mj)do if self:same_type(gA,ci)then mk=false;break end end;if mk then table.insert(bD,gA)end end;if#bD==0 then return aF(aG,"nil",{})end;return jp(aG,bD)end;local ml;local mm;local mn;local mo;local mp;local function mq(ct)return az({fact="is",var=ct.var,typ=aF(ct.w,"invalid",{}),w=ct.w})end;mm=function(self,h8)local eU={}for ee,ct in pairs(h8)do local aL=self:find_var_type(ct.var,"check_only")if not aL then eU[ee]=ay({var=ee,typ=aF(ct.w,"invalid",{}),w=ct.w,no_infer=ct.no_infer})elseif ct.fact=="=="then eU[ee]=ay({var=ee,typ=aL,w=ct.w,no_infer=true})elseif aL.typename=="typevar"then assert(ct.fact=="is")eU[ee]=ay({var=ee,typ=aL,w=ct.w,no_infer=true})elseif not self:is_a(ct.typ,aL)then assert(ct.fact=="is")self.errs:add_warning("branch",ct.w,ct.var.." (of type %s) can never be a %s",aD(aL),aD(ct.typ))eU[ee]=ay({var=ee,typ=aF(ct.w,"invalid",{}),w=ct.w,no_infer=ct.no_infer})else assert(ct.fact=="is")eU[ee]=az({var=ee,typ=mi(self,ct.w,aL,ct.typ),w=ct.w,no_infer=ct.no_infer})end end;return eU end;ml=function(self,ct)if not ct then return{}elseif ct.fact=="is"then return mm(self,{[ct.var]=ct})elseif ct.fact=="not"then return mp(self,ct.f1)elseif ct.fact=="and"and ct.f2 and ct.f2.fact=="truthy"then return ml(self,ct.f1)elseif ct.fact=="or"and ct.f2 and ct.f2.fact=="truthy"then return ml(self,ct.f1)elseif ct.fact=="and"then return mn(self,ml(self,ct.f1),ml(self,ct.f2))elseif ct.fact=="or"then return mo(self,ml(self,ct.f1),ml(self,ct.f2))else return mm(self,mp(self,ct))end end;mn=function(jU,mr,ms)local eU={}for ee,ct in pairs(ms)do if mr[ee]then local mt=mg(ct.w,ct.typ,mr[ee].typ)if mr[ee].fact=="is"and ct.fact=="is"then eU[ee]=az({var=ee,typ=mt,w=ct.w})else eU[ee]=ay({var=ee,typ=mt,w=ct.w})end end end;return eU end;mo=function(self,mr,ms)local eU={}local lv={}for ee,ct in pairs(mr)do local fV;local mu=ay;if ms[ee]then if ms[ee].fact=="is"and ct.fact=="is"then mu=az end;fV=mh(self,ct.w,ct.typ,ms[ee].typ)else fV=ct.typ end;local mv=mu({var=ee,typ=fV,w=ct.w,no_infer=ct.no_infer})eU[ee]=mv;lv[mv.fact]=true end;for ee,ct in pairs(ms)do if not mr[ee]then eU[ee]=ay({var=ee,typ=ct.typ,w=ct.w,no_infer=ct.no_infer})lv["=="]=true end end;if lv["is"]and lv["=="]then for E,ct in pairs(eU)do ct.fact="=="end end;return eU end;mp=function(self,ct)if not ct then return{}elseif ct.fact=="is"then local aL=self:find_var_type(ct.var,"check_only")if not aL then return{[ct.var]=mq(ct)}end;if not(aL.typename=="typevar")then if self:is_a(aL,ct.typ)then return{[ct.var]=ct}elseif not self:is_a(ct.typ,aL)then self.errs:add(ct.w,ct.var.." (of type %s) can never be a %s",aL,ct.typ)return{[ct.var]=mq(ct)}end end;return{[ct.var]=ct}elseif ct.fact=="=="then return{[ct.var]=ct}elseif ct.fact=="not"then return ml(self,ct.f1)elseif ct.fact=="truthy"then return{}elseif ct.fact=="and"and ct.f2 and ct.f2.fact=="truthy"then return mp(self,ct.f1)elseif ct.fact=="or"and ct.f2 and ct.f2.fact=="truthy"then return ml(self,ct.f1)elseif ct.fact=="and"then return mo(self,mp(self,ct.f1),mp(self,ct.f2))elseif ct.fact=="or"then return mn(self,mp(self,ct.f1),mp(self,ct.f2))end end;function i0:apply_facts(aG,mw)if not mw then return end;local mx=mp(self,mw)for aP,ct in pairs(mx)do if ct.typ.typename=="invalid"then self.errs:add(aG,"cannot resolve a type for "..aP.." here")end;local aa=ct.no_infer and ct.typ or self:infer_at(aG,ct.typ)if ct.no_infer then aa.inferred_at=nil end;self:add_var(nil,aP,aa,"const","narrow")end end;if n then local my=-1;local mz=mp;mp=function(self,mw)my=my+1;io.stderr:write(("   "):rep(my))io.stderr:write("eval fact: ",tostring(mw),"\n")local mx=mz(self,mw)if mx then for E,ac in ipairs(fR(mx))do local ct=mx[ac]io.stderr:write(("   "):rep(my),"=> ",tostring(ct),"\n")end else io.stderr:write(("   "):rep(my),"=> .\n")end;my=my-1;return mx end end end;function i0:dismiss_unresolved(u)for J=#self.st,1,-1 do local eb=self.st[J]local mA=eb.pending_nominals and eb.pending_nominals[u]if mA then for E,aa in ipairs(mA)do self:resolve_nominal(aa)end;eb.pending_nominals[u]=nil;return end end end;local function mB(self,b4,jV,aY,jW)local mC=b4.e1.tk=="xpcall"and 2 or 1;local mD=aF(b4,"boolean",{})if#b4.e2<mC then self.errs:add(b4,"wrong number of arguments (given "..#b4.e2 ..", expects at least "..mC..")")return aF(b4,"tuple",{tuple={mD}})end;local fx=table.remove(aY.tuple,1)fx=i9(fx)local mE=hI(b4.e2,{})if b4.e1.tk=="xpcall"then mC=2;local mF=b4.e2[2]local mG=table.remove(aY.tuple,1)local mH=aJ(mF,{min_arity=self.feat_arity and 1 or 0,args=aF(mF,"tuple",{tuple={aF(mF,"any",{})}}),rets=aF(mF,"tuple",{tuple={}})})self:assert_is_a(mF,mG,mH,"in message handler")end;for J=mC+1,#b4.e2 do table.insert(mE,b4.e2[J])end;local mI=hI(b4,{kind="op",op={op="@funcall"},e1=b4.e2[1],e2=mE})local fW=self:type_check_funcall(mI,fx,aY,jW+mC)if fW.typename=="invalid"then return fW end;table.insert(fW.tuple,1,mD)return fW end;local mJ={["pairs"]=function(self,b4,aX,aY,jW)if not aY.tuple[1]then return self.errs:invalid_at(b4,"pairs requires an argument")end;local aa=self:to_structural(aY.tuple[1])if aa.elements then self.errs:add_warning("hint",b4,"hint: applying pairs on an array: did you intend to apply ipairs?")end;if not(aa.typename=="map")then if not(self.feat_lax and h2(aa))then if aa.fields then self:match_all_record_field_names(b4.e2,aa,aa.field_order,"attempting pairs on a record with attributes of different types")local iE=aa.typename=="record"and"{string:any}"or"{any:any}"self.errs:add_warning("hint",b4.e2,"hint: if you want to iterate over fields of a record, cast it to "..iE)else self.errs:add(b4.e2,"cannot apply pairs on values of type: %s",aa)end end end;return self:type_check_function_call(b4,aX,aY,jW)end,["ipairs"]=function(self,b4,aX,aY,jW)if not aY.tuple[1]then return self.errs:invalid_at(b4,"ipairs requires an argument")end;local iC=aY.tuple[1]local aa=self:to_structural(iC)if aa.typename=="tupletable"then local jw=self:arraytype_from_tuple(b4.e2,aa)if not jw then return self.errs:invalid_at(b4.e2,"attempting ipairs on tuple that's not a valid array: %s",iC)end elseif not aa.elements then if not(self.feat_lax and(h2(aa)or aa.typename=="emptytable"))then return self.errs:invalid_at(b4.e2,"attempting ipairs on something that's not an array: %s",iC)end end;return self:type_check_function_call(b4,aX,aY,jW)end,["rawget"]=function(self,b4,jV,aY,mK)if#aY.tuple==2 then return aF(b4,"tuple",{tuple={self:type_check_index(b4.e2[1],b4.e2[2],aY.tuple[1],aY.tuple[2])}})else return self.errs:invalid_at(b4,"rawget expects two arguments")end end,["require"]=function(self,b4,jV,aY,mK)if#aY.tuple~=1 then return self.errs:invalid_at(b4,"require expects one literal argument")end;if b4.e2[1].kind~="string"then return aF(b4,"tuple",{tuple={aF(b4,"any",{})}})end;local hg=assert(b4.e2[1].conststr)local hZ={feat_lax=self.feat_lax and"on"or"off",feat_arity=self.feat_arity and"on"or"off"}local aa,mL=hp(b4,hg,hZ,self.env)if aa.typename=="invalid"then if not mL then return self.errs:invalid_at(b4,"module not found: '"..hg.."'")end;if self.feat_lax then return aF(b4,"tuple",{tuple={aF(b4,"unknown",{})}})end;return self.errs:invalid_at(b4,"no type information for required module: '"..hg.."'")end;self.dependencies[hg]=mL;return aF(b4,"tuple",{tuple={aa}})end,["pcall"]=mB,["xpcall"]=mB,["assert"]=function(self,b4,aX,aY,jW)b4.known=m5;local cx=self:type_check_function_call(b4,aX,aY,jW)self:apply_facts(b4,b4.e2[1].known)return cx end}function i0:type_check_funcall(b4,aX,aY,jW)jW=jW or 0;if b4.e1.kind=="variable"then local mM=mJ[b4.e1.tk]if mM then return mM(self,b4,aX,aY,jW)else return self:type_check_function_call(b4,aX,aY,jW)end elseif b4.e1.op and b4.e1.op.op==":"then table.insert(aY.tuple,1,b4.e1.receiver)return self:type_check_function_call(b4,aX,aY,-1)else return self:type_check_function_call(b4,aX,aY,jW)end end;local function mN(b4,J)return b4.exps and b4.exps[J]and b4.exps[J].kind=="variable"and b4.exps[J].tk==b4.vars[J].tk end;function i0:missing_initializer(b4,J,u)if self.feat_lax then return aF(b4,"unknown",{})else if b4.exps then return self.errs:invalid_at(b4.vars[J],"assignment in declaration did not produce an initial value for variable '"..u.."'")else return self.errs:invalid_at(b4.vars[J],"variable '"..u.."' has no type or initial value")end end end;local function mO(self,b4,fC)local mP=b4.kind=="assignment"and fC[1]or b4.decltuple;assert(mP.typename=="tuple")local mQ=mP.tuple;if mQ and b4.exps then local mR=#mQ;local mS=#b4.exps;for J=1,mS do local aL;aL=mQ[J]if aL then if J==mS and mR>mS and b3(b4.exps[J])then aL=aF(b4,"tuple",{tuple={}})for aX=J,mR do table.insert(aL.tuple,mQ[aX])end end;b4.exps[J].expected=aL;b4.exps[J].expected_context={kind=b4.kind,name=b4.vars[J].tk}end end end;if b4.decltuple then local mT=#b4.decltuple.tuple;local mU=#b4.vars;if mT>mU then self.errs:add(b4.decltuple.tuple[mU+1],"number of types exceeds number of variables")end end end;local function mV(b2)return b2 and b2>=1 and math.floor(b2)==b2 end;local function mW(self,b4,fC)local mX=false;local mY=false;local mZ=false;local m_=false;local n0=false;local n1=1;local n2=-1;local gS={}local bD;local dE;local dF;local n3;local fS,jP;for J,eN in ipairs(fC)do local n4=eN.kname;local n5=eN.ktype;local cM=n4;local b2;if not cM then b2=b4[J].key.constnum;cM=b2;if not cM and b4[J].key.kind=="boolean"then cM=b4[J].key.tk=="true"end end;self.errs:check_redeclared_key(b4[J],nil,gS,cM)local n6=iJ(eN.vtype)if n4 then mX=true;if not dE then dE={}dF={}end;dE[n4]=n6;table.insert(dF,n4)elseif at(n5)then mY=true;if not n0 then m_=true end;if not bD then bD={}end;if b4[J].key_parsed=="implicit"then local n7=eN.vtype;if J==#fC and n7.typename=="tuple"then for E,y in ipairs(n7.tuple)do n3=self:expand_type(b4,n3,y)bD[n1]=iJ(y)n1=n1+1 end else bD[n1]=n6;n1=n1+1;n3=self:expand_type(b4,n3,n6)end else if not mV(b2)then n3=self:expand_type(b4,n3,n6)n0=true elseif b2 then bD[b2]=n6;if b2>n2 then n2=b2 end;n3=self:expand_type(b4,n3,n6)end end;if n1>n2 then n2=n1 end;if not n3 then mY=false end else mZ=true;fS=self:expand_type(b4,fS,is(n5))jP=self:expand_type(b4,jP,n6)end end;local aa;if mY and mZ then self.errs:add(b4,"cannot determine type of table literal")aa=aF(b4,"map",{keys=self:expand_type(b4,fS,aF(b4,"integer",{})),values=self:expand_type(b4,jP,n3)})elseif mX and mY then aa=aF(b4,"record",{fields=dE,field_order=dF,elements=n3,interface_list={aF(b4,"array",{elements=n3})}})elseif mX and mZ then if fS.typename=="string"then for E,fw in ipairs(dF)do jP=self:expand_type(b4,jP,dE[fw])end;aa=aF(b4,"map",{keys=fS,values=jP})else self.errs:add(b4,"cannot determine type of table literal")end elseif mY then local n8=true;if not n0 then local n9;for E,na in pairs(bD)do if n9 then if not self:same_type(n9,na)then n8=false;break end end;n9=na end end;if n8 then aa=aF(b4,"array",{elements=n3})aa.consttypes=bD;aa.inferred_len=n2-1 else aa=aF(b4,"tupletable",{inferred_at=b4})aa.types=bD end elseif mX then aa=aF(b4,"record",{fields=dE,field_order=dF})elseif mZ then aa=aF(b4,"map",{keys=fS,values=jP})elseif m_ then aa=aF(b4,"tupletable",{inferred_at=b4})aa.types=bD;if not bD or#bD==0 then self.errs:add(b4,"cannot determine type of tuple elements")end end;if not aa then aa=aF(b4,"emptytable",{})end;return iM(b4,aa)end;function i0:infer_negation_of_if_blocks(aG,nb,b2)local ct=m4(aG,nb.if_blocks[1].exp.known)for al=2,b2 do local aY=nb.if_blocks[al]if aY.exp then ct=m2(aG,ct,m4(aG,aY.exp.known))end end;self:apply_facts(aG,ct)end;function i0:determine_declaration_type(ee,b4,nc,J)local bO=true;local u=ee.tk;local nd=nc and nc.tuple[J]if self.feat_lax and nd and nd.typename=="nil"then nd=nil end;local ne=b4.decltuple and b4.decltuple.tuple[J]if ne then local nf=self:to_structural(ne)if nf.typename=="invalid"then ne=nf end;if nd then local aG=b4.exps and b4.exps[J]or b4.vars[J]bO=self:assert_is_a(aG,nd,ne,gu[b4.kind],u)end else if nd then if nd.typename=="unresolvable_typearg"then bO=false;nd=self.errs:invalid_at(b4.vars[J],"cannot infer declaration type; an explicit type annotation is necessary")else nd=i9(nd)end end end;if ee.attribute=="total"then local ng=ne and self:to_structural(ne)if ng and not(ng.typename=="map")and not(ng.typename=="record")then self.errs:add(ee,"attribute <total> only applies to maps and records")bO=false elseif not nd then self.errs:add(ee,"variable declared <total> does not declare an initialization value")bO=false else local nh=b4.exps[J]if not nh or nh.kind~="literal_table"then self.errs:add(ee,"attribute <total> only applies to literal tables")bO=false else if not nh.is_total then local ni=""if nh.missing then ni=" (missing: "..table.concat(nh.missing,", ")..")"end;local nj=self:to_structural(nd)if nj.typename=="map"then self.errs:add(ee,"map variable declared <total> does not declare values for all possible keys"..ni)bO=false elseif nj.typename=="record"then self.errs:add(ee,"record variable declared <total> does not declare values for all fields"..ni)bO=false end end end end end;local aa=ne or nd;if aa==nil then aa=self:missing_initializer(b4,J,u)elseif aa.typename=="emptytable"then aa.declared_at=b4;aa.assigned_to=u elseif aa.elements then aa.inferred_len=nil elseif aa.typename=="nominal"then self:resolve_nominal(aa)local fV=aa.resolved;if fV and fV.typename=="typedecl"then aa.resolved=fV.def end end;return bO,aa,nd~=nil end;local function nk(self,bB)if bB.typename=="nominal"then return self:find_var(bB.names[1],"use_type")end;if bB.typename=="generic"then local g0=bB.t;if g0.typename=="nominal"then return self:find_var(g0.names[1],"use_type")end end end;local function nl(self,b2)if b2.kind=="op"then if b2.op.op=="."then local Y=nl(self,b2.e1)if not(Y.typename=="typedecl")then return Y end;local bB=Y.def;if not(bB.typename=="record")then return self.errs:invalid_at(b2.e1,"type is not a record")end;local aa=bB.fields[b2.e2.tk]if aa and aa.typename=="typedecl"then return aa end;return self.errs:invalid_at(b2.e2,"nested type '"..b2.e2.tk.."' not found in record")elseif b2.op.op=="@funcall"and b2.e1.kind=="variable"and b2.e1.tk=="require"then local Y=iJ(mJ["require"](self,b2,self:find_var_type("require"),aF(b2.e2,"tuple",{tuple={aF(b2.e2[1],"string",{})}})))if not(Y.typename=="typedecl")then return self.errs:invalid_at(b2.e1,"'require' did not return a type, got %s",Y)end;if Y.is_alias then return self:resolve_typealias(Y)end;return Y end end;local nm=b2.newtype;if nm.is_alias then return self:resolve_typealias(nm),nk(self,nm.def)end;return nm,nil end;function i0:get_typedecl(nn)local g1,no=nl(self,nn)local W=nn.newtype;if W and W.is_alias and g1.typename=="typedecl"then local np=W.def;local nq=g1.def;if np.typename=="generic"and nq.typename=="generic"then np.typeargs=nq.typeargs end end;return g1,no end;local function nr(cM,gS,ns,ni)if not gS[cM]then ni=ni or{}table.insert(ni,tostring(cM))return false,ni end;return ns,ni end;local function nt(aa,gS)local ns=true;local ni;for E,cM in ipairs(aa.field_order)do local fx=aa.fields[cM]if not(fx.typename=="typedecl"or fx.typename=="function"and fx.is_record_function)then ns,ni=nr(cM,gS,ns,ni)end end;return ns,ni end;local function nu(fS,gS)local ns=true;local ni;if fS.typename=="enum"then for E,cM in ipairs(fR(fS.enumset))do ns,ni=nr(cM,gS,ns,ni)end elseif fS.typename=="boolean"then for E,cM in ipairs({true,false})do ns,ni=nr(cM,gS,ns,ni)end else ns=false end;return ns,ni end;function i0:check_assignment(nv,nw,lE)local lD=nv.tk;local nx=nv.attribute;if lD then if self:widen_back_var(lD)then nw,nx=self:find_var_type(lD)if not nw then self.errs:add(nv,"unknown variable")return nil end end end;if nx=="close"or nx=="const"or nx=="total"then self.errs:add(nv,"cannot assign to <"..nx.."> variable")return nil end;local ee=self:to_structural(nw)if ee.typename=="typedecl"then self.errs:add(nv,"cannot reassign a type")return nil end;if not lE then self.errs:add(nv,"variable is not being assigned a value")return nil,nil,"missing"end;self:assert_is_a(nv,lE,nw,"in assignment")local am=self:to_structural(lE)return ee,am end;local function ny(b4,aa,aY)if aY.typename=="tuple"then b4.discarded_tuple=true end;return iJ(aa)end;local f0={}f0.cbs={["statements"]={before=function(self,b4)self:begin_scope(b4)end,after=function(self,b4,fA)if#self.st==2 then self.errs:fail_unresolved_labels(self.st[2])self.errs:fail_unresolved_nominals(self.st[2],self.st[1])end;if not b4.is_repeat then self:end_scope(b4)end;return j1 end},["local_type"]={before=function(self,b4)local u=b4.var.tk;local g1,no=self:get_typedecl(b4.value)local ee=self:add_var(b4.var,u,g1,b4.var.attribute)if no then ee.aliasing=no end end,after=function(self,b4,fA)self:dismiss_unresolved(b4.var.tk)return j1 end},["global_type"]={before=function(self,b4)local gR=self.st[1]local u=b4.var.tk;if b4.value then local g1,no=self:get_typedecl(b4.value)local nz=self:add_global(b4.var,u,g1)if g1.typename=="invalid"then return end;b4.value.newtype=g1;if no then nz.aliasing=no end;if gR.pending_global_types[u]then gR.pending_global_types[u]=nil end else if not self.st[1].vars[u]then gR.pending_global_types[u]=true end end end,after=function(self,b4,fA)self:dismiss_unresolved(b4.var.tk)return j1 end},["local_declaration"]={before=function(self,b4)if self.collector then for E,ee in ipairs(b4.vars)do self.collector.reserve_symbol_list_slot(ee)end end end,before_exp=mO,after=function(self,b4,fC)local nA=fC[3]local nB=false;local nc=lO(b4,nA,#b4.vars)for J,ee in ipairs(b4.vars)do if ee.attribute=="close"then if self.gen_target=="5.4"then if nB then self.errs:add(ee,"only one <close> per declaration is allowed")else nB=true end else self.errs:add(ee,"<close> attribute is only valid for Lua 5.4 (current target is "..tostring(self.gen_target)..")")end end;local bO,aa=self:determine_declaration_type(ee,b4,nc,J)if ee.attribute=="close"then if not kl(aa)then self.errs:add(ee,"to-be-closed variable "..ee.tk.." has a non-closable type %s",aa)elseif b4.exps and b4.exps[J]and kn(b4.exps[J])then self.errs:add(ee,"to-be-closed variable "..ee.tk.." assigned a non-closable value")end end;assert(ee)self:add_var(ee,ee.tk,aa,ee.attribute,mN(b4,J)and"localizing")if ee.elide_type then self.errs:add_warning("hint",b4,"hint: consider using 'local type' instead")end;local nd=nc.tuple[J]if bO and nd then local aG=b4.exps[J]or b4.exps;local fV=self:to_structural(aa)if not(fV.typename=="enum")and(not(aa.typename=="nominal")or fV.typename=="union")and not self:same_type(aa,nd)then aa=self:infer_at(aG,nd)self:add_var(aG,ee.tk,aa,"const","narrowed_declaration")end end;if self.collector then self.collector.store_type(ee.y,ee.x,aa)end;self:dismiss_unresolved(ee.tk)end;return j1 end},["global_declaration"]={before_exp=mO,after=function(self,b4,fC)local nA=fC[3]local nc=lO(b4,nA,#b4.vars)for J,ee in ipairs(b4.vars)do local E,aa,nC=self:determine_declaration_type(ee,b4,nc,J)if ee.attribute=="close"then self.errs:add(ee,"globals may not be <close>")end;self:add_global(ee,ee.tk,aa,nC)if ee.elide_type then self.errs:add_warning("hint",b4,"hint: consider using 'global type' instead")end;self:dismiss_unresolved(ee.tk)end;return j1 end},["assignment"]={before_exp=mO,after=function(self,b4,fC)local nD=fC[1]assert(nD.typename=="tuple")local nE=nD.tuple;local nA=fC[3]assert(nA.typename=="tuple")local nF=lO(b4,nA,#nE)for J,nw in ipairs(nE)do local nv=b4.vars[J]local lD=nv.tk;local lE=nF.tuple[J]local nG,nH,aW=self:check_assignment(nv,nw,lE)if aW=="missing"then if#b4.exps==1 and b3(b4.exps[1])then local a9=#nA.tuple==1 and"only 1 value is returned by the function"or"only "..#nA.tuple.." values are returned by the function"self.errs:add_warning("hint",nv,a9)end end;if nH and nG then if nH.typename=="function"then self:widen_all_unions()end;if lD and(nG.typename=="union"or nG.typename=="interface")then self:add_var(nv,lD,nH,nil,"narrow")end;if self.collector then self.collector.store_type(nv.y,nv.x,lE)end end end;return j1 end},["if"]={after=function(self,b4,fA)if b4.if_widens then self:widen_all(b4.if_widens)end;local nI=true;for E,aY in ipairs(b4.if_blocks)do if not aY.block_returns then nI=false;break end end;if nI then b4.block_returns=true;self:infer_negation_of_if_blocks(b4,b4,#b4.if_blocks)end;return j1 end},["if_block"]={before=function(self,b4)self:begin_scope(b4)if b4.if_block_n>1 then self:infer_negation_of_if_blocks(b4,b4.if_parent,b4.if_block_n-1)end;if b4.exp then b4.exp.expected=aF(b4,"boolean_context",{})end end,before_statements=function(self,b4)if b4.exp then self:apply_facts(b4.exp,b4.exp.known)end end,after=function(self,b4,fA)b4.if_parent.if_widens=self:collect_if_widens(b4.if_parent.if_widens)self:end_scope(b4)if#b4.body>0 and b4.body[#b4.body].block_returns then b4.block_returns=true end;return j1 end},["while"]={before=function(self,b4)self:widen_all_unions(b4)b4.exp.expected=aF(b4,"boolean_context",{})end,before_statements=function(self,b4)self:begin_scope(b4)self:apply_facts(b4.exp,b4.exp.known)end,after=j2},["label"]={before=function(self,b4)self:widen_all_unions()local nJ=b4.label;do local eb=self.st[#self.st]eb.labels=eb.labels or{}if eb.labels[nJ]then self.errs:add(b4,"label '"..b4.label.."' already defined")else eb.labels[nJ]=b4 end end;local eb=self.st[#self.st]if eb.pending_labels and eb.pending_labels[nJ]then b4.used_label=true;eb.pending_labels[nJ]=nil end end,after=function()return j1 end},["goto"]={after=function(self,b4,fA)local nJ=b4.label;local nK;for J=#self.st,1,-1 do local eb=self.st[J]if eb.labels and eb.labels[nJ]then nK=eb.labels[nJ]break end end;if nK then nK.used_label=true else local eb=self.st[#self.st]eb.pending_labels=eb.pending_labels or{}eb.pending_labels[nJ]=eb.pending_labels[nJ]or{}table.insert(eb.pending_labels[nJ],b4)end;return j1 end},["repeat"]={before=function(self,b4)self:widen_all_unions(b4)b4.exp.expected=aF(b4,"boolean_context",{})end,after=j2},["forin"]={before=function(self,b4)self:begin_scope(b4)end,before_statements=function(self,b4,fC)local nL=fC[2]assert(nL.typename=="tuple")local nM=nL.tuple;local nN=b4.exps[1]if#nM<1 then self.errs:invalid_at(nN,"expression in 'for' statement does not return any values")return end;self:widen_all_unions(b4)local cP=aF(b4.exps,"tuple",{tuple={b4.exps[2]and nM[2],b4.exps[3]and nM[3]}})local nO=self:resolve_for_call(nM[1],cP,false)if nO.typename=="poly"then local nP,ct;nP,ct=self:type_check_function_call(nN,nO,cP,0,nN,{b4.exps[2],b4.exps[3]})if ct then nO=ct else self.errs:add(nN,"cannot resolve polymorphic function given arguments")end end;if nO.typename=="function"then local lN;local fW=nO.rets;for J,aP in ipairs(b4.vars)do local cx=fW.tuple[J]if not cx then if fW.is_va then cx=lN else cx=self.feat_lax and aF(aP,"unknown",{})or aF(aP,"invalid",{})end end;self:add_var(aP,aP.tk,cx)if self.collector then self.collector.store_type(aP.y,aP.x,cx)end;lN=cx end;local co=#fW.tuple;if not self.feat_lax and(not fW.is_va and#b4.vars>co)then local gA=b4.vars[co+1]local nQ=co==1 and"1 value"or tostring(co).." values"self.errs:add(gA,"too many variables for this iterator; it produces "..nQ)end else if not(self.feat_lax and h2(nO))then self.errs:add(nN,"expression in for loop does not return an iterator")end end end,after=j2},["fornum"]={before_statements=function(self,b4,fC)self:widen_all_unions(b4)self:begin_scope(b4)local nR=self:to_structural(iJ(fC[2]))local nS=self:to_structural(iJ(fC[3]))local nT=fC[4]and self:to_structural(fC[4])local aH=nR.typename=="integer"and nS.typename=="integer"and(not nT or nT.typename=="integer")and"integer"or"number"self:add_var(b4.var,b4.var.tk,aF(b4.var,aH,{}))end,after=j2},["return"]={before=function(self,b4)local fW=self:find_var_type("@return")if fW and fW.typename=="tuple"then for J,e8 in ipairs(b4.exps)do e8.expected=fW.tuple[J]end end end,after=function(self,b4,fC)local nU=fC[1]assert(nU.typename=="tuple")local nV=nU.tuple;local nW=#nV;b4.block_returns=true;local lh=self:find_var_type("@return")if not lh then local h_=iJ(nU)if h_.typename=="nominal"then self:resolve_nominal(h_)self.module_type=h_.resolved else self.module_type=is(h_)end;lh=self:infer_at(b4,nU)self.st[2].vars["@return"]={t=lh}end;local nX=lh.tuple;local h5="in return value"if lh.inferred_at then h5=h5 ..he(lh)end;local nY=#nX;local nZ;if nY>0 then nZ=lh.is_va and lh.tuple[nY]end;if nW>nY and not self.feat_lax and not nZ then self.errs:add(b4,h5 ..": excess return values, expected "..nY.." %s, got "..nW.." %s",lh,nU)end;if nY>1 and#b4.exps==1 and b4.exps[1].kind=="op"and(b4.exps[1].op.op=="and"or b4.exps[1].op.op=="or")and b4.exps[1].discarded_tuple then self.errs:add_warning("hint",b4.exps[1].e2,"additional return values are being discarded due to '"..b4.exps[1].op.op.."' expression; suggest parentheses if intentional")end;for J=1,nW do local al=nX[J]or nZ;if al then al=iJ(al)local aG=b4.exps[J]and b4.exps[J].x and b4.exps[J]or b4.exps;assert(aG and aG.x)self:assert_is_a(aG,nV[J],al,h5)end end;return j1 end},["variable_list"]={after=function(self,b4,fC)local n_=lL(b4,fC)for J,aa in ipairs(n_.tuple)do local bO,aW=gK(aa,b4[J])if not bO then self.errs:add(b4[J],aW)end end;return n_ end},["literal_table"]={before=function(self,b4)if b4.expected then local ne=self:to_structural(b4.expected)if ne.typename=="typevar"and ne.constraint then ne=it(self:to_structural(ne.constraint))end;if ne.typename=="generic"then ne=self:apply_generic(b4,ne)end;if ne.typename=="tupletable"then for E,eN in ipairs(b4)do local b2=eN.key.constnum;if b2 and mV(b2)then eN.value.expected=ne.types[b2]end end elseif ne.elements then for E,eN in ipairs(b4)do if eN.key.constnum then eN.value.expected=ne.elements end end elseif ne.typename=="map"then for E,eN in ipairs(b4)do eN.key.expected=ne.keys;eN.value.expected=ne.values end end;if ne.fields then for E,eN in ipairs(b4)do if eN.key.conststr then eN.value.expected=ne.fields[eN.key.conststr]end end end end end,after=function(self,b4,fC)b4.known=m5;if not b4.expected then return mW(self,b4,fC)end;local ne=self:to_structural(b4.expected)local cb;if ne.typename=="typevar"and ne.constraint then cb=it(ne.constraint)ne=self:to_structural(cb)end;if ne.typename=="generic"then ne=self:apply_generic(b4,ne)end;if ne.typename=="union"then local o0;local o1;for E,aa in ipairs(ne.types)do local fV=self:to_structural(aa)if jo(fV)then if o0 then o0=nil;o1=nil;break end;o0=aa;o1=fV end end;if o0 then b4.expected=o0;ne=o1 end end;if not jo(ne)then return mW(self,b4,fC)end;if ne.fields then self:begin_scope()self:add_var(nil,"@self",aF(b4,"typedecl",{def=ne}))ne=self:resolve_self(ne,true)self:end_scope()end;local o2=nil;local gS={}for J,eN in ipairs(fC)do local o3=iJ(eN.vtype)local n4=eN.kname;local n5=eN.ktype;local b2=b4[J].key.constnum;local aY=nil;if n5.typename=="boolean"then aY=b4[J].key.tk=="true"end;self.errs:check_redeclared_key(b4[J],b4,gS,n4 or b2 or aY)if ne.fields and n4 then local o4=ne.fields[n4]if not o4 then self.errs:add_in_context(b4[J],b4,"unknown field "..n4)else if o4.typename=="typedecl"then self.errs:add_in_context(b4[J],b4,"cannot reassign a type")else self:assert_is_a(b4[J],o3,o4,"in record field",n4)end end elseif ne.typename=="tupletable"and at(n5)then local o5=ne.types[b2]if not b2 then self.errs:add_in_context(b4[J],b4,"unknown index in tuple %s",ne)elseif not o5 then self.errs:add_in_context(b4[J],b4,"unexpected index "..b2 .." in tuple %s",ne)else self:assert_is_a(b4[J],o3,o5,b4,"in tuple: at index "..tostring(b2))end elseif ne.elements and at(n5)then local n7=eN.vtype;if n7.typename=="tuple"and J==#fC and b4[J].key_parsed=="implicit"then for Z,bR in ipairs(n7.tuple)do self:assert_is_a(b4[J],bR,ne.elements,b4,"expected an array: at index "..tostring(J+Z-1))end else self:assert_is_a(b4[J],o3,ne.elements,b4,"expected an array: at index "..tostring(b2))end elseif b4[J].key_parsed=="implicit"then if ne.typename=="map"then self:assert_is_a(b4[J].key,aF(b4[J].key,"integer",{}),ne.keys,b4,"in map key")self:assert_is_a(b4[J].value,o3,ne.values,b4,"in map value")end;o2=self:expand_type(b4[J],o2,eN.vtype)elseif ne.typename=="map"then o2=nil;self:assert_is_a(b4[J].key,n5,ne.keys,b4,"in map key")self:assert_is_a(b4[J].value,o3,ne.values,b4,"in map value")else self.errs:add_in_context(b4[J],b4,"unexpected key of type %s in table of type %s",n5,ne)end end;local aa=o2 and aF(b4,"array",{elements=o2})or b4.expected;aa=self:infer_at(b4,aa)if ne.typename=="record"then local fV=self:to_structural(aa)if fV.typename=="record"then b4.is_total,b4.missing=nt(ne,gS)end elseif ne.typename=="map"then local fV=self:to_structural(aa)if fV.typename=="map"then local o6=self:to_structural(fV.keys)b4.is_total,b4.missing=nu(o6,gS)end end;if cb then return cb end;return aa end},["literal_table_item"]={after=function(self,b4,fC)local o7=b4.key.conststr;local o8=fC[1]local o9=fC[2]if b4.itemtype then o9=b4.itemtype;self:assert_is_a(b4.value,fC[2],b4.itemtype,b4)end;o9=i9(o9)return aF(b4,"literal_table_item",{kname=o7,ktype=o8,vtype=o9})end},["local_function"]={before=function(self,b4)self:widen_all_unions()if self.collector then self.collector.reserve_symbol_list_slot(b4)end;self:begin_scope(b4)end,before_statements=function(self,b4,fC)local cP=fC[2]assert(cP.typename=="tuple")self:add_internal_function_variables(b4,cP)self:add_function_definition_for_recursion(b4,cP,self.feat_arity)end,after=function(self,b4,fC)local cP=fC[2]assert(cP.typename=="tuple")local fW=fC[3]assert(fW.typename=="tuple")self:end_function_scope(b4)local aa=i8(b4.typeargs,aJ(b4,{min_arity=self.feat_arity and b4.min_arity or 0,args=cP,rets=self.get_rets(fW)}))self:add_var(b4,b4.name.tk,aa)return aa end},["local_macroexp"]={before=function(self,b4)self:widen_all_unions()if self.collector then self.collector.reserve_symbol_list_slot(b4)end;self:begin_scope(b4)end,after=function(self,b4,fC)local cP=fC[2]assert(cP.typename=="tuple")local fW=fC[3]assert(fW.typename=="tuple")self:end_function_scope(b4)self:check_macroexp_arg_use(b4.macrodef)local aa=i8(b4.typeargs,aJ(b4,{min_arity=self.feat_arity and b4.macrodef.min_arity or 0,args=cP,rets=self.get_rets(fW),macroexp=b4.macrodef}))self:add_var(b4,b4.name.tk,aa)return aa end},["global_function"]={before=function(self,b4)self:widen_all_unions()self:begin_scope(b4)if b4.implicit_global_function then local aL=self:find_var_type(b4.name.tk)if aL then if aL.typename=="function"then b4.is_predeclared_local_function=true elseif not self.feat_lax then self.errs:add(b4,"cannot declare function: type of "..b4.name.tk.." is %s",aL)end elseif not self.feat_lax then self.errs:add(b4,"functions need an explicit 'local' or 'global' annotation")end end end,before_statements=function(self,b4,fC)local cP=fC[2]assert(cP.typename=="tuple")self:add_internal_function_variables(b4,cP)self:add_function_definition_for_recursion(b4,cP,self.feat_arity)end,after=function(self,b4,fC)local cP=fC[2]assert(cP.typename=="tuple")local fW=fC[3]assert(fW.typename=="tuple")self:end_function_scope(b4)if b4.is_predeclared_local_function then return j1 end;self:add_global(b4,b4.name.tk,i8(b4.typeargs,aJ(b4,{min_arity=self.feat_arity and b4.min_arity or 0,args=cP,rets=self.get_rets(fW)})))return j1 end},["record_function"]={before=function(self,b4)self:widen_all_unions()self:begin_scope(b4)end,before_arguments=function(self,lB,fC)local f_=self:to_structural(it(fC[1]))if f_.typename=="generic"then for E,aL in ipairs(f_.typeargs)do self:add_var(nil,aL.typearg,aF(aL,"typearg",{typearg=aL.typearg,constraint=aL.constraint}))end end end,before_statements=function(self,b4,fC)local cP=fC[3]assert(cP.typename=="tuple")local fW=fC[4]assert(fW.typename=="tuple")local aa=fC[1]local f_=self:to_structural(it(aa))if f_.typename=="generic"then f_=f_.t end;do local bO,aW=gK(aa)if not bO then self.errs:add(b4,aW)end end;if self.feat_lax and f_.typename=="unknown"then return end;if f_.typename=="emptytable"then aI(f_,f_,"record")local cx=f_;cx.fields={}cx.field_order={}end;if not f_.fields then self.errs:add(b4,"not a record: %s",f_)return end;local l4=self:get_self_type(b4.fn_owner)if b4.is_method then if not l4 then self.errs:add(b4,"could not resolve type of self")return end;cP.tuple[1]=aF(b4,"self",{display_type=l4})self:add_var(nil,"self",l4)self:add_var(nil,"@self",aF(b4,"typedecl",{def=l4}))if self.collector then self.collector.add_to_symbol_list(b4.fn_owner,"self",l4)end end;local oa=i8(b4.typeargs,aJ(b4,{min_arity=self.feat_arity and b4.min_arity or 0,is_method=b4.is_method,args=cP,rets=self.get_rets(fW),is_record_function=true}))local ob,oc,od=self:find_record_to_extend(b4.fn_owner)local oe=od.."."..b4.name.tk;local of=f_.fields[b4.name.tk]if of then of=self:to_structural(of)if oc and oc.implemented and oc.implemented[oe]then self.errs:redeclaration_warning(b4,b4.name.tk,"function")end;if oa.typename=="generic"and not(of.typename=="generic")then self:begin_scope()oa=self:apply_generic(b4,oa)self:end_scope()end;local bO,aW=self:same_type(oa,of)if not bO then if of.typename=="poly"then self.errs:add_prefixing(b4,aW,"type signature does not match declaration: field has multiple function definitions (such polymorphic declarations are intended for Lua module interoperability): ")return end;local og=l4 and aD(l4)or od;local a9="type signature of '"..b4.name.tk.."' does not match its declaration in "..og..": "self.errs:add_prefixing(b4,aW,a9)return end else if ob and ob.typename=="generic"then ob=ob.t end;if self.feat_lax or f_==ob then f_.fields[b4.name.tk]=oa;table.insert(f_.field_order,b4.name.tk)if self.collector then self.env.reporter:add_field(f_,b4.name.tk,oa)end else self.errs:add(b4,"cannot add undeclared function '"..b4.name.tk.."' outside of the scope where '"..od.."' was originally declared")return end end;if oc then if not oc.implemented then oc.implemented={}end;oc.implemented[oe]=true end;self:add_internal_function_variables(b4,cP)end,after=function(self,b4,fA)self:end_function_scope(b4)return j1 end},["function"]={before=function(self,b4)self:widen_all_unions(b4)self:begin_scope(b4)local lh=b4.expected;if lh and lh.typename=="function"then for J,aa in ipairs(lh.args.tuple)do if b4.args[J]then b4.args[J].expected=aa end end end end,before_statements=function(self,b4,fC)local cP=fC[1]assert(cP.typename=="tuple")self:add_internal_function_variables(b4,cP)end,after=function(self,b4,fC)local cP=fC[1]assert(cP.typename=="tuple")local fW=fC[2]assert(fW.typename=="tuple")self:end_function_scope(b4)return i8(b4.typeargs,aJ(b4,{min_arity=self.feat_arity and b4.min_arity or 0,args=cP,rets=self.get_rets(fW)}))end},["macroexp"]={before=function(self,b4)self:widen_all_unions(b4)self:begin_scope(b4)end,before_exp=function(self,b4,fC)local cP=fC[1]assert(cP.typename=="tuple")self:add_internal_function_variables(b4,cP)end,after=function(self,b4,fC)local cP=fC[1]assert(cP.typename=="tuple")local fW=fC[2]assert(fW.typename=="tuple")self:end_function_scope(b4)return i8(b4.typeargs,aJ(b4,{min_arity=self.feat_arity and b4.min_arity or 0,args=cP,rets=fW}))end},["cast"]={after=function(jU,b4,fA)return b4.casttype end},["paren"]={before=function(jU,b4)b4.e1.expected=b4.expected end,after=function(jU,b4,fC)b4.known=b4.e1 and b4.e1.known;return iJ(fC[1])end},["op"]={before=function(self,b4)self:begin_scope()if b4.expected then if b4.op.op=="and"then b4.e2.expected=b4.expected elseif b4.op.op=="or"then b4.e1.expected=b4.expected;if not(b4.e2.kind=="literal_table"and#b4.e2==0)then b4.e2.expected=b4.expected end end end end,before_e2=function(self,b4,fC)local oh=fC[1]if b4.op.op=="and"then self:apply_facts(b4,b4.e1.known)elseif b4.op.op=="or"then self:apply_facts(b4,m4(b4,b4.e1.known))if b4.e1.kind=="op"and b4.e1.op.op=="and"and b4.e1.e1.kind=="op"and b4.e1.e1.op.op=="is"and b4.e1.e2.kind=="variable"and b4.e1.e2.tk==b4.e1.e1.e1.tk and b4.e1.e1.e2.casttype.typename~="boolean"and b4.e1.e1.e2.casttype.typename~="nil"then self:apply_facts(b4,m4(b4,az({var=b4.e1.e1.e1.tk,typ=b4.e1.e1.e2.casttype,w=b4})))end elseif b4.op.op=="@funcall"then if oh.typename=="generic"then oh=self:apply_generic(b4,oh)end;if oh.typename=="function"then local jW=b4.e1.op and b4.e1.op.op==":"and-1 or 0;if b4.expected then self:is_a(oh.rets,b4.expected)end;local oi=oh.args.tuple;local gA=jW;for E,aL in ipairs(oi)do gA=gA+1;if b4.e2[gA]then b4.e2[gA].expected=self:infer_at(b4.e2[gA],aL)end end;if oh.args.is_va then local aL=oi[#oi]for J=gA+1,#b4.e2 do b4.e2[J].expected=self:infer_at(b4.e2[J],aL)end end end elseif b4.op.op=="@index"then if oh.typename=="map"then b4.e2.expected=oh.keys end end end,after=function(self,b4,fC)self:end_scope()local oj=fC[1]local ok=fC[3]local ol=iJ(oj)local om;local jz=self:to_structural(ol)local jf;if jz.typename=="circular_require"or jz.typename=="typedecl"and jz.def and jz.def.typename=="circular_require"then return self.errs:invalid_at(b4,"cannot dereference a type from a circular require")end;if b4.op.op=="@funcall"then if self.feat_lax and h2(ol)then if b4.e1.op and b4.e1.op.op==":"and b4.e1.e1.kind=="variable"then self.errs:add_unknown_dot(b4,b4.e1.e1.tk.."."..b4.e1.e2.tk)end end;assert(ok.typename=="tuple")local aa=self:type_check_funcall(b4,ol,ok)return aa elseif b4.op.op=="as"then local bO,aW=gK(jz)if not bO then return self.errs:invalid_at(b4.e1,aW)end;return ok elseif b4.op.op=="is"and jz.typename=="typedecl"then return self.errs:invalid_at(b4,"can only use 'is' on variables, not types")end;local bO,aW=gK(jz)if not bO then return self.errs:invalid_at(b4.e1,aW)end;if jz.typename=="typedecl"and jz.def.typename=="record"then jz=jz.def end;if ok then om=iJ(ok)jf=self:to_structural(om)bO,aW=gK(jf)if not bO then return self.errs:invalid_at(b4.e2,aW)end;if jf.typename=="typedecl"and jf.def.typename=="record"then jf=jf.def end end;if b4.op.op=="."then b4.receiver=ol;assert(b4.e2.kind=="identifier")local lS=hI(b4.e2,{tk=b4.e2.tk,kind="string"})local on=aF(b4.e2,"string",{literal=b4.e2.tk})local aa=self:type_check_index(b4.e1,lS,ol,on)if aa.needs_compat and self.gen_compat~="off"then if b4.e1.kind=="variable"and b4.e2.kind=="identifier"then local cM=b4.e1.tk.."."..b4.e2.tk;b4.kind="variable"b4.tk="_tl_"..b4.e1.tk.."_"..b4.e2.tk;self.all_needs_compat[cM]=true end end;return aa end;if b4.op.op=="@index"then return self:type_check_index(b4.e1,b4.e2,ol,om)end;if b4.op.op=="is"then local oo=false;if jf.typename=="integer"then self.all_needs_compat["math"]=true elseif not(jf.typename=="nil")then oo=true end;if jz.typename=="typedecl"then self.errs:add(b4,"can only use 'is' on variables, not types")elseif b4.e1.kind=="variable"then local op;if jf.typename=="union"then op=lw(self,b4,jz,jf)else local E,ey=self:check_metamethod(b4,"__is",jz,it(jf),ol,om)b4.known=az({var=b4.e1.tk,typ=om,w=b4})op=not not ey end;if op then oo=false end else self.errs:add(b4,"can only use 'is' on variables")end;if oo then self.all_needs_compat["type"]=true end;return aF(b4,"boolean",{})end;if b4.op.op==":"then b4.receiver=ol;if self.feat_lax and(h2(ol)or ol.typename=="typevar")then if b4.e1.kind=="variable"then self.errs:add_unknown_dot(b4.e1,b4.e1.tk.."."..b4.e2.tk)end;return aF(b4,"unknown",{})end;local aa,al=self:match_record_key(jz,b4.e1,b4.e2.conststr or b4.e2.tk)if not aa then return self.errs:invalid_at(b4.e2,al,ol)end;return aa end;if b4.op.op=="not"then b4.known=m4(b4,b4.e1.known)return aF(b4,"boolean",{})end;if b4.op.op=="and"then b4.known=m2(b4,b4.e1.known,b4.e2.known)return ny(b4,om,ok)end;if b4.op.op=="or"then local aa;local lh=b4.expected and self:to_structural(iJ(b4.expected))if om.typename=="nil"then b4.known=nil;aa=ol elseif jo(jz)and jf.typename=="emptytable"then b4.known=nil;aa=ol elseif jz.typename=="enum"and jf.typename=="string"and self:is_a(jf,jz)or jz.typename=="string"and jf.typename=="enum"and self:is_a(jz,jf)then b4.known=nil;aa=jz.typename=="enum"and jz or jf elseif lh and lh.typename=="union"then b4.known=m3(b4,b4.e1.known,b4.e2.known)local cj=jp(b4,{jz,jf},true)if cj.typename=="union"then bO,aW=ie(cj)if not bO then cj=aW and self.errs:invalid_at(b4,aW,cj)or aF(b4,"invalid",{})end end;aa=cj else local oq=self:is_a(jf,jz)local ot=self:is_a(jz,jf)b4.known=m3(b4,b4.e1.known,b4.e2.known)if oq or ot then if lh then local ou=self:is_a(ol,lh)local ov=self:is_a(om,lh)if ou and ov then aa=self:infer_at(b4,lh)end end;if not aa then local ow=ot and om or ol;aa=ow end;aa=is(aa)end;if lh and lh.typename=="boolean_context"then aa=aF(b4,"boolean",{})end end;if aa then return ny(b4,aa,ok)end end;if b4.op.op=="=="or b4.op.op=="~="then if jo(jz)and jo(jf)then self:check_metamethod(b4,h0[b4.op.op],jz,jf,ol,om)end;if jz.typename=="enum"and jf.typename=="string"then if not(jf.literal and jz.enumset[jf.literal])then return self.errs:invalid_at(b4,"%s is not a member of %s",om,ol)end elseif jz.typename=="tupletable"and jf.typename=="tupletable"and#jz.types~=#jf.types then return self.errs:invalid_at(b4,"tuples are not the same size")elseif self:is_a(om,ol)or ol.typename=="typevar"then if b4.op.op=="=="and b4.e1.kind=="variable"then b4.known=ay({var=b4.e1.tk,typ=om,w=b4})end elseif self:is_a(ol,om)or om.typename=="typevar"then if b4.op.op=="=="and b4.e2.kind=="variable"then b4.known=ay({var=b4.e2.tk,typ=ol,w=b4})end elseif self.feat_lax and(h2(ol)or h2(om))then return aF(b4,"unknown",{})else return self.errs:invalid_at(b4,"types are not comparable for equality: %s and %s",ol,om)end;return aF(b4,"boolean",{})end;if b4.op.arity==1 and gY[b4.op.op]then if jz.typename=="union"then jz=jp(b4,jz.types,true)end;local ox=gY[b4.op.op]local bw=ox[jz.typename]local aa=bw and aF(b4,bw,{})if not aa and jz.fields then if jz.interface_list then for E,dV in ipairs(jz.interface_list)do if ox[dV.typename]then aa=aF(b4,ox[dV.typename],{})break end end end end;local lp;if not aa then local hO=gZ[b4.op.op]if hO then aa,lp=self:check_metamethod(b4,hO,jz,nil,ol,nil)end end;if jz.typename=="map"then if jz.keys.typename=="number"or jz.keys.typename=="integer"then self.errs:add_warning("hint",b4,"using the '#' operator on a map with numeric key type may produce unexpected results")else self.errs:add(b4,"using the '#' operator on this map will always return 0")end end;if b4.op.op=="~"and self.gen_target=="5.1"then if lp then self.all_needs_compat["mt"]=true;hN(b4,gZ[b4.op.op],1,b4.e1)else self.all_needs_compat["bit32"]=true;hJ(b4,"bit32","bnot",b4.e1)end end;if not aa then return self.errs:invalid_at(b4,"cannot use operator '"..b4.op.op:gsub("%%","%%%%").."' on type %s",ol)end;if not(aa.typename=="boolean"or h2(aa))then b4.known=m5 end;return aa end;if b4.op.arity==2 and g_[b4.op.op]then if b4.op.op=="or"then b4.known=m3(b4,b4.e1.known,b4.e2.known)end;if jz.typename=="union"then jz=jp(jz,jz.types,true)end;if jf.typename=="union"then jf=jp(jf,jf.types,true)end;local ox=g_[b4.op.op]local bw=ox[jz.typename]and ox[jz.typename][jf.typename]local aa=bw and aF(b4,bw,{})local lp;if not aa then local hO=h0[b4.op.op]local lm=false;if not hO then hO=h1[b4.op.op]if hO then lm=true;jz,jf=jf,jz;ol,om=om,ol end end;if hO then aa,lp=self:check_metamethod(b4,hO,jz,jf,ol,om,lm)if lm and not lp then jz,jf=jf,jz;ol,om=om,ol end end end;if not aa and ol.typename=="nominal"and om.typename=="nominal"and not lp then if self:is_a(ol,om)then aa=ol end end;if ox==gT or b4.op.op==".."then b4.known=m5 end;if b4.op.op=="//"and self.gen_target=="5.1"then if lp then self.all_needs_compat["mt"]=true;hN(b4,"__idiv",lp,b4.e1,b4.e2)else local oy=hI(b4,{kind="op",op=aM(b4,2,"/"),e1=b4.e1,e2=b4.e2})hJ(b4,"math","floor",oy)end elseif hH[b4.op.op]and self.gen_target=="5.1"then if lp then self.all_needs_compat["mt"]=true;hN(b4,h0[b4.op.op],lp,b4.e1,b4.e2)else self.all_needs_compat["bit32"]=true;hJ(b4,"bit32",hH[b4.op.op],b4.e1,b4.e2)end end;if not aa then if b4.op.op=="or"then local cj=jp(b4,{ol,om})if cj.typename=="union"and ie(cj)then self.errs:add_warning("hint",b4,"if a union type was intended, consider declaring it explicitly")end end;return self.errs:invalid_at(b4,"cannot use operator '"..b4.op.op:gsub("%%","%%%%").."' for types %s and %s",ol,om)end;return aa end;error("unknown node op "..b4.op.op)end},["variable"]={after=function(self,b4,fA)if b4.tk=="..."then local oz=self:find_var_type("@is_va")if not oz or oz.typename=="nil"then return self.errs:invalid_at(b4,"cannot use '...' outside a vararg function")end end;local aa;if b4.tk=="_G"then aa,b4.attribute=self:simulate_g()else local i1=b4.is_lvalue and"lvalue"or"use"aa,b4.attribute=self:find_var_type(b4.tk,i1)end;if not aa then if self.feat_lax then self.errs:add_unknown(b4,b4.tk)return aF(b4,"unknown",{})end;return self.errs:invalid_at(b4,"unknown variable: "..b4.tk)end;if aa.typename=="typedecl"then aa=m0(b4,b4.tk,aa,aa)end;return aa end},["type_identifier"]={after=function(self,b4,fA)local aL,nx=self:find_var_type(b4.tk)b4.attribute=nx;if aL then return aL end;if self.feat_lax then self.errs:add_unknown(b4,b4.tk)return aF(b4,"unknown",{})end;return self.errs:invalid_at(b4,"unknown variable: "..b4.tk)end},["argument"]={after=function(self,b4,fC)local aa=fC[1]if not aa then if b4.expected and b4.tk=="self"then aa=b4.expected else aa=self.feat_lax and aF(b4,"unknown",{})or aF(b4,"any",{})end end;if b4.tk=="..."then aa=aK(b4,{aa})end;self:add_var(b4,b4.tk,aa).is_func_arg=true;return aa end},["identifier"]={after=function(jU,lB,fA)return j1 end},["newtype"]={after=function(jU,b4,fA)return b4.newtype end},["pragma"]={after=function(self,b4,fA)if b4.pkey=="arity"then if b4.pvalue=="on"then self.feat_arity=true elseif b4.pvalue=="off"then self.feat_arity=false else return self.errs:invalid_at(b4,"invalid value for pragma 'arity': "..b4.pvalue)end else return self.errs:invalid_at(b4,"invalid pragma: "..b4.pkey)end;return j1 end},["error_node"]={after=function(jU,b4,fA)return aF(b4,"invalid",{})end}}f0.cbs["break"]={after=function(jU,lB,fA)return j1 end}f0.cbs["do"]=f0.cbs["break"]local function oA(jU,b4)b4.known=m5;return aF(b4,b4.kind,{})end;f0.cbs["string"]={after=function(self,b4,fA)local aa=oA(self,b4)aa.literal=b4.conststr;local lh=b4.expected and self:to_structural(b4.expected)if lh and lh.typename=="enum"and self:is_a(aa,lh)then return b4.expected end;return aa end}f0.cbs["number"]={after=oA}f0.cbs["integer"]={after=oA}f0.cbs["boolean"]={after=function(self,b4,fA)local aa=oA(self,b4)b4.known=b4.tk=="true"and m5 or nil;return aa end}f0.cbs["nil"]=f0.cbs["boolean"]f0.cbs["..."]=f0.cbs["variable"]f0.cbs["argument_list"]=f0.cbs["variable_list"]f0.cbs["expression_list"]=f0.cbs["variable_list"]f0.after=function(jU,b4,fA,aa)if b4.expanded then kG(b4)end;return aa end;function i0:resolve_self(aa,oB)local l4,oC=self:type_of_self(aa)local oD=l4;if l4.typename=="generic"then oD=l4.t end;if oB and oD.typename=="interface"or oD.typename=="record"then return i2(self,aa,{["self"]=function(E,aL)return m0(aL,oD.declname,oC)end})else return aa end end;do local function oE(self,dE,dF,g1,oF,ag)for fw,fx in ex(g1,ag)do if dE[fw]then if not self:is_a(dE[fw],fx)then local h5=ag=="meta"and"metamethod"or"field"self.errs:add(dE[fw],h5 .." '"..fw.."' does not match definition in interface %s",oF)end else table.insert(dF,fw)if fx.typename=="typedecl"then dE[fw]=fx else dE[fw]=self:resolve_self(fx)end end end end;local function oG(self,ag,aa,hb)if aa.interface_list then for E,dV in ipairs(aa.interface_list)do if dV.typename=="nominal"then local nj=self:resolve_nominal(dV)if nj.typename=="interface"then if nj.interfaces_expanded and not hb[nj]then hb[nj]=true;oG(self,ag,nj,hb)end;table.insert(ag,dV)else self.errs:add(dV,"attempted to use %s as interface, but its type is %s",dV,nj)end else if not hb[dV]then hb[dV]=true;table.insert(ag,dV)end end end end;return ag end;function i0:expand_interfaces(aa)if aa.interfaces_expanded then return end;aa.interfaces_expanded=true;aa.interface_list=oG(self,{},aa,{})for E,dV in ipairs(aa.interface_list)do if dV.typename=="nominal"then local nj=self:resolve_nominal(dV)assert(nj.typename=="interface")oE(self,aa.fields,aa.field_order,nj,dV)if nj.meta_fields then aa.meta_fields=aa.meta_fields or{}aa.meta_field_order=aa.meta_field_order or{}oE(self,aa.meta_fields,aa.meta_field_order,nj,dV,"meta")end else if not aa.elements then aa.elements=dV else if not self:same_type(dV.elements,aa.elements)then self.errs:add(aa,"incompatible array interfaces")end end end end end end;function i0:begin_temporary_record_types(aL)self:add_var(nil,"@self",aF(aL,"typedecl",{def=aL}))for fw,fx in ex(aL)do if fx.typename=="typedecl"then local bB=fx.def;if bB.typename=="nominal"then assert(fx.is_alias)self:resolve_nominal(bB)end;self:add_var(nil,fw,fx)end end end;function i0:end_temporary_record_types(aL)local eb=self.st[#self.st]eb.vars["@self"]=nil;for fw,fx in ex(aL)do if fx.typename=="typedecl"then eb.vars[fw]=nil end end end;local function oH(aL,oI,i6)if oI.typename=="self"then return true end;if not(oI.typename=="nominal")then return false end;if#oI.names~=1 or oI.names[1]~=aL.declname then return false end;if i6 then if not oI.typevals then return false end;if i6.t.typeid~=aL.typeid then return false end;for dU=1,#i6.typeargs do local j7=oI.typevals[dU]if not(j7 and j7.typename=="typevar"and j7.typevar==i6.typeargs[dU].typearg)then return false end end end;return true end;local oJ={["__bnot"]=true,["__call"]=true,["__close"]=true,["__gc"]=true,["__index"]=true,["__is"]=true,["__len"]=true,["__newindex"]=true,["__pairs"]=true,["__tostring"]=true,["__unm"]=true}local eY;eY={cbs={["generic"]={before=function(self,aL)self:begin_scope()self:add_var(nil,"@generic",aL)end,after=function(self,aL,fA)self:end_scope()return i5(self,aL)end},["function"]={after=function(self,aL,fA)if self.feat_arity==false then aL.min_arity=0 end;return aL end},["record"]={before=function(self,aL)self:begin_scope()self:begin_temporary_record_types(aL)end,after=function(self,aL,fC)local J=1;if aL.interface_list then for dU,E in ipairs(aL.interface_list)do local dV=fC[J]if dV.typename=="array"then aL.interface_list[dU]=dV elseif dV.typename=="nominal"then local nj=self:resolve_nominal(dV)if nj.typename=="interface"then aL.interface_list[dU]=dV else self.errs:add(fC[J],"%s is not an interface",fC[J])end end;J=J+1 end end;if aL.elements then aL.elements=fC[J]J=J+1 end;local oK;local i6;for u,E in ex(aL)do local fx=fC[J]if fx.typename=="function"then if fx.macroexp then oK=oK or{}table.insert(oK,fx)end;if fx.is_method then local l5=fx.args.tuple;if l5[1]then if not i6 then i6=self:find_var("@generic")end;fx.is_method=oH(aL,l5[1],i6 and i6.t)if fx.is_method then l5[1]=aF(l5[1],"self",{display_type=aL})end end end elseif fx.typename=="typedecl"and fx.is_alias then self:resolve_typealias(fx)end;aL.fields[u]=fx;J=J+1 end;for u,E in ex(aL,"meta")do local fx=fC[J]if fx.typename=="function"then if fx.macroexp then oK=oK or{}table.insert(oK,fx)end;fx.is_method=oJ[u]end;aL.meta_fields[u]=fx;J=J+1 end;if aL.interface_list then self:expand_interfaces(aL)if self.collector then for fw,fx in ex(aL)do self.env.reporter:add_field(aL,fw,fx)end end end;if oK then for E,aa in ipairs(oK)do local oL=f4(self,aa.macroexp,f0,eY)self:check_macroexp_arg_use(aa.macroexp)if not self:is_a(oL,aa)then self.errs:add(oL,"macroexp type does not match declaration")end end end;self:end_temporary_record_types(aL)self:end_scope()return aL end},["typearg"]={after=function(self,aL,fA)local u=aL.typearg;local iL=self:find_var(u,"check_only")if iL then self.errs:redeclaration_warning(aL,u,"type argument",iL)end;if b0[u]then self.errs:add(aL,"cannot use base type name '"..u.."' as a type variable")end;self:add_var(nil,u,aF(aL,"typearg",{typearg=u,constraint=aL.constraint}))return aL end},["typevar"]={after=function(self,aL,fA)if not self:find_var_type(aL.typevar)then self.errs:add(aL,"undefined type variable "..aL.typevar)end;return aL end},["nominal"]={after=function(self,aL,fA)if aL.found then return aL end;local aa,eZ=self:find_type(aL.names)if aa then local bB=aa.def;if aa.is_alias then if bB.typename=="generic"then bB=bB.t end;if bB.typename=="nominal"then aL.found=bB.found end elseif bB.typename~="circular_require"then aL.found=aa end elseif eZ then aL.names=nil;aI(aL,aL,"typevar")local j7=aL;j7.typevar=eZ.typearg;j7.constraint=eZ.constraint else local u=aL.names[1]local eb=self.st[#self.st]eb.pending_nominals=eb.pending_nominals or{}eb.pending_nominals[u]=eb.pending_nominals[u]or{}table.insert(eb.pending_nominals[u],aL)end;return aL end},["union"]={after=function(self,aL,fA)local E,aW=ie(aL)if aW then return self.errs:invalid_at(aL,aW,aL)end;return aL end}}}local fM={after=function(jU,aL,fA)return aL end}eY.cbs["interface"]=eY.cbs["record"]eY.cbs["typedecl"]=fM;eY.cbs["self"]=fM;eY.cbs["string"]=fM;eY.cbs["tupletable"]=fM;eY.cbs["array"]=fM;eY.cbs["map"]=fM;eY.cbs["enum"]=fM;eY.cbs["boolean"]=fM;eY.cbs["nil"]=fM;eY.cbs["number"]=fM;eY.cbs["integer"]=fM;eY.cbs["thread"]=fM;eY.cbs["emptytable"]=fM;eY.cbs["literal_table_item"]=fM;eY.cbs["unresolved_emptytable_value"]=fM;eY.cbs["tuple"]=fM;eY.cbs["poly"]=fM;eY.cbs["any"]=fM;eY.cbs["unknown"]=fM;eY.cbs["invalid"]=fM;eY.cbs["none"]=fM;local function oM(dd)return function(ak,b2,fC,aa)aa=dd and dd(ak,b2,fC,aa)or aa;if type(aa)~="table"then error((b2.kind or b2.typename).." did not produce a type")end;if type(aa.typename)~="string"then error((b2.kind or b2.typename).." type does not have a typename")end;return aa end end;local function oN(dd)return function(self,b2,fC,aa)aa=dd and dd(self,b2,fC,aa)or aa;local aG=b2;if aG.y then self.collector.store_type(aG.y,aG.x,aa)end;return aa end end;local function oO(dd)return function(ak,b4,fC,aa)aa=dd and dd(ak,b4,fC,aa)or aa;b4.debug_type=aa;return aa end end;local function oP(oQ,oR,oS,oT)if oQ==f0 then oQ=aQ(oQ)end;oQ.after=oR(oQ.after)if oS then if oS==eY then oS=aQ(oS)end;oS.after=oT(oS.after)else oS=eY end;return oQ,oS end;local function oU(oV,oW)if oV then return oV=="on"else return oW end end;h.check=function(eK,L,d0,hq)L=L or"?"d0=d0 or{}if not hq then local aW;hq,aW=h.new_env({defaults=d0})if aW then return nil,aW end end;local self={filename=L,env=hq,st={{vars=hq.globals,pending_global_types={}}},errs=g.new(L),all_needs_compat={},dependencies={},subtype_relations=i0.subtype_relations,eqtype_relations=i0.eqtype_relations,type_priorities=i0.type_priorities}self.cache_std_metatable_type=hq.globals["metatable"]and hq.globals["metatable"].t.def;setmetatable(self,{__index=i0,__tostring=function()return"TypeChecker"end})self.feat_lax=oU(d0.feat_lax or hq.defaults.feat_lax,false)self.feat_arity=oU(d0.feat_arity or hq.defaults.feat_arity,true)self.gen_compat=d0.gen_compat or hq.defaults.gen_compat or k;self.gen_target=d0.gen_target or hq.defaults.gen_target or l;if self.feat_lax then self.feat_arity=false end;if self.gen_target=="5.4"and self.gen_compat~="off"then return nil,"gen-compat must be explicitly 'off' when gen-target is '5.4'"end;if self.feat_lax then self.type_priorities=aQ(self.type_priorities)self.type_priorities["unknown"]=0;self.subtype_relations=aQ(self.subtype_relations)self.subtype_relations["unknown"]={}self.subtype_relations["unknown"]["*"]=jy;self.subtype_relations["*"]=aQ(self.subtype_relations["*"])self.subtype_relations["*"]["unknown"]=jy;self.subtype_relations["*"]["boolean"]=jy;self.get_rets=function(fW)if#fW.tuple==0 then return aK(fW,{aF(fW,"unknown",{})})end;return fW end else self.get_rets=function(fW)return fW end end;if hq.report_types then hq.reporter=hq.reporter or h.new_type_reporter()self.collector=hq.reporter:get_collector(L)end;local f0,eY=f0,eY;if d0.run_internal_compiler_checks then f0,eY=oP(f0,oM,eY,oM)end;if self.collector then f0,eY=oP(f0,oN,eY,oN)end;if m then f0,eY=oP(f0,oO)end;assert(eK.kind=="statements")f4(self,eK,f0,eY)local gR=self.st[1]iW(gR)self.errs:check_var_usage(gR,true)aR(self.errs.errors)hw(eK,self.all_needs_compat,self.gen_compat)local hV={ast=eK,env=hq,type=self.module_type or aF(eK,"boolean",{}),filename=L,warnings=self.errs.warnings,type_errors=self.errs.errors,dependencies=self.dependencies}hq.loaded[L]=hV;table.insert(hq.loaded_order,L or"")if self.collector then hq.reporter:store_result(self.collector,hq.globals)end;return hV end end;local function oX(hn)local oY="\239\187\191"local oZ,aW=hn:read("*a")if not oZ then return nil,aW end;if oZ:sub(1,oY:len())==oY then oZ=oZ:sub(oY:len()+1)end;return oZ,aW end;local function o_(L,I)if L then local p0="(.*)%.([a-z]+)$"local E,p1=L:match(p0)p1=p1 and p1:lower()if p1=="tl"then return"tl"elseif p1=="lua"then return"lua"end end;if I then return I:match("^#![^\n]*lua[^\n]*\n")and"lua"or"tl"end;return"tl"end;local function p2(p3)return p3=="tl"and"off"or"on"end;h.check_file=function(L,hq,hn)if hq and hq.loaded and hq.loaded[L]then return hq.loaded[L]end;local I,aW;if not hn then hn,aW=io.open(L,"rb")if not hn then return nil,"could not open "..L..": "..aW end end;I,aW=oX(hn)hn:close()if not I then return nil,"could not read "..L..": "..aW end;return h.check_string(I,hq,L)end;function h.target_from_lua_version(cs)if cs=="Lua 5.1"or cs=="Lua 5.2"then return"5.1"elseif cs=="Lua 5.3"then return"5.3"elseif cs=="Lua 5.4"then return"5.4"end end;local function p4(p5,eu)local fi=p5 and h.target_from_lua_version(_VERSION)or l;local hz=fi=="5.4"and"off"or k;return{defaults={feat_lax=p2(eu),gen_target=fi,gen_compat=hz,run_internal_compiler_checks=false}}end;function h.check_string(I,hq,L,eu)eu=eu or o_(L,I)hq=hq or h.new_env(p4(false,eu))if hq.loaded and hq.loaded[L]then return hq.loaded[L]end;L=L or""local hx,hU=h.parse(I,L,eu)if not hq.keep_going and#hU>0 then local hV={ok=false,filename=L,type=aF({f=L,y=1,x=1},"boolean",{}),type_errors={},syntax_errors=hU,env=hq}hq.loaded[L]=hV;table.insert(hq.loaded_order,L)return hV end;local hV=h.check(hx,L,hq.defaults,hq)hV.syntax_errors=hU;return hV end;h.gen=function(I,hq,d0,eu)eu=eu or o_(nil,I)hq=hq or assert(h.new_env(p4(false,eu)),"Default environment initialization failed")local hV=h.check_string(I,hq)if not hV.ast or#hV.syntax_errors>0 then return nil,hV end;local fO;fO,hV.gen_error=h.generate(hV.ast,hq.defaults.gen_target,d0)return fO,hV end;local function p6(hg)local p7,hn,hj=h.search_module(hg,false)if p7 then local eu=o_(p7)local I=oX(hn)if not I then return table.concat(hj,"\n\t")end;hn:close()local hx,V=h.parse(I,p7,eu)if#V>0 then error(p7 ..":"..V[1].y..":"..V[1].x..": "..V[1].msg)end;local hq=h.package_loader_env;if not hq then h.package_loader_env=assert(h.new_env(),"Default environment initialization failed")hq=h.package_loader_env end;local d0=p4(true,eu)local aG={f=p7,x=1,y=1}hq.modules[hg]=aF(aG,"typedecl",{def=aF(aG,"circular_require",{})})local hV=h.check(hx,p7,d0.defaults,hq)hq.modules[hg]=hV.type;local fO=assert(h.generate(hx,d0.defaults.gen_target,fg))local p8,aW=load(fO,"@"..p7,"t")if p8 then return function(p9,pa)if pa==nil then pa=p7 end;local eU=p8(p9,pa)return eU end,p7 else error("Internal Compiler Error: Teal generator produced invalid Lua. Please report a bug at https://github.com/teal-language/tl\n\n"..aW)end end;return table.concat(hj,"\n\t")end;function h.loader()if package.searchers then table.insert(package.searchers,2,p6)else table.insert(package.loaders,2,p6)end end;local function pb(d0,pc)if not pc then if not h.package_loader_env then h.package_loader_env=h.new_env(d0)end;return h.package_loader_env end;if not h.load_envs then h.load_envs=setmetatable({},{__mode="k"})end;h.load_envs[pc]=h.load_envs[pc]or h.new_env(d0)return h.load_envs[pc]end;h.load=function(I,pd,ck,...)local eu=o_(pd)local hx,V=h.parse(I,pd,eu)if#V>0 then return nil,(pd or"")..":"..V[1].y..":"..V[1].x..": "..V[1].msg end;local d0=p4(true,eu)if not h.package_loader_env then h.package_loader_env=h.new_env(d0)end;local L=pd or"string \""..I:sub(45)..(#I>45 and"..."or"").."\""local hV=h.check(hx,L,d0.defaults,pb(d0,...))if ck and ck:match("c")then if#hV.type_errors>0 then local pe={}for E,aW in ipairs(hV.type_errors)do table.insert(pe,aW.filename..":"..aW.y..":"..aW.x..": "..(aW.msg or""))end;return nil,table.concat(pe,"\n")end;ck=ck:gsub("c","")end;local fO,aW=h.generate(hx,d0.defaults.gen_target,fg)if not fO then return nil,aW end;return load(fO,pd,ck,...)end;h.version=function()return e end;function h.get_types(hV)return hV.env.reporter:get_report(),hV.env.reporter end;h.init_env=function(pf,hz,fi,pg)local d0={defaults={feat_lax=pf and"on"or"off",gen_compat=type(hz)=="string"and hz or hz==false and"off"or(hz==true or hz==nil)and"optional",gen_target=fi or(_VERSION=="Lua 5.1"or _VERSION=="Lua 5.2")and"5.1"or"5.3"},predefined_modules=pg}return h.new_env(d0)end;h.type_check=function(eK,hZ)local d0={feat_lax=hZ.lax and"on"or"off",feat_arity=hZ.env and hZ.env.defaults.feat_arity or"on",gen_compat=hZ.gen_compat,gen_target=hZ.gen_target,run_internal_compiler_checks=hZ.run_internal_compiler_checks}return h.check(eK,hZ.filename,d0,hZ.env)end;h.pretty_print_ast=function(eK,fi,ck)local d0;if type(ck)=="table"then d0=ck elseif ck==true then d0=fg else d0=ff end;return h.generate(eK,fi,d0)end;h.process=function(L,hq,hn)return h.check_file(L,hq,hn)end;h.process_string=function(I,ph,hq,L,pi)return h.check_string(I,hq or h.init_env(ph),L)end;return h